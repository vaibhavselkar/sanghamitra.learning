<script>
/*
  Improved CT Quiz Script (Option A)
  - Developer-tools detection removed (per request)
  - Dynamic topic via URL ?topic=...
  - Autosave / restore progress using localStorage
  - Case-insensitive topic query (client-side normalization)
  - Fixed/complete resetUserProgress & other functions
  - Modular, commented
*/

(() => {
  // ----- State -----
  let userAnswers = {};          // { questionIndex: answer | [answers] }
  let currentUser = {};
  let username = null;
  let email = null;
  let currentQuestionIndex = 0;
  let quizStartTime = null;
  let questionStartTime = null;
  let questionTimes = {};        // seconds per question by index
  let questions = [];
  let cheatingAttempts = 0;
  let isQuizActive = false;
  let autosaveTimer = null;

  // Default topic, can be overridden by URL param ?topic=...
  let topic = getTopicFromURL() || 'Programming Basics';

  // LocalStorage keys
  const LS_PREFIX = 'ct_quiz_v1';
  const LS_KEY = `${LS_PREFIX}_${sanitizeKey(topic)}_progress`;

  // ----- Utilities -----
  function sanitizeKey(s) {
    return s.toString().replace(/\s+/g, '_').replace(/[^\w\-]/g, '').toLowerCase();
  }

  function getTopicFromURL() {
    try {
      const params = new URLSearchParams(window.location.search);
      const t = params.get('topic');
      return t ? t : null;
    } catch (e) {
      return null;
    }
  }

  function safeLog(...args) {
    console.log('[CT QUIZ]', ...args);
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // ----- Autosave / Restore -----
  function loadSavedProgress() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return false;
      const parsed = JSON.parse(raw);
      userAnswers = parsed.userAnswers || {};
      questionTimes = parsed.questionTimes || {};
      currentQuestionIndex = parsed.currentQuestionIndex || 0;
      safeLog('Restored progress from localStorage', parsed);
      return true;
    } catch (e) {
      console.warn('Failed to restore saved progress', e);
      return false;
    }
  }

  function saveProgressToLocal() {
    try {
      const payload = {
        userAnswers,
        questionTimes,
        currentQuestionIndex,
        savedAt: new Date()
      };
      localStorage.setItem(LS_KEY, JSON.stringify(payload));
      safeLog('Autosaved progress to localStorage');
    } catch (e) {
      console.warn('Failed to save progress', e);
    }
  }

  function clearSavedProgress() {
    try {
      localStorage.removeItem(LS_KEY);
    } catch (e) {
      console.warn('Failed to clear saved progress', e);
    }
  }

  function startAutosave() {
    if (autosaveTimer) clearInterval(autosaveTimer);
    autosaveTimer = setInterval(saveProgressToLocal, 5000);
  }

  function stopAutosave() {
    if (autosaveTimer) clearInterval(autosaveTimer);
    autosaveTimer = null;
  }

  // ----- Fetch session info -----
  async function fetchSessionInfo() {
    try {
      const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/session-info', {
        credentials: 'include'
      });

      if (response.ok) {
        const data = await response.json();
        username = data.username;
        email = data.email;
        currentUser = { username, email };
        safeLog('Session found:', username, email);
        return true;
      } else {
        safeLog('Session invalid, redirecting to login');
        alert('Please login to take the assessment');
        window.location.href = '/login.html';
        return false;
      }
    } catch (error) {
      console.error('Error fetching session info:', error);
      alert('Error connecting to server. Please try again.');
      return false;
    }
  }

  // ----- Load questions -----
  async function loadQuestions() {
    try {
      if (!email) {
        alert('Please login to take the assessment');
        return false;
      }

      // We send topic encoded; backend expects exact match, so we try to fetch with the given topic.
      // If backend should be case-insensitive, ideally update server; client tries exact topic first.
      const encoded = encodeURIComponent(topic);
      const url = `https://sanghamitra-learnworld.vercel.app/api/iitm-ct-questions?topic=${encoded}`;

      const response = await fetch(url, { credentials: 'include' });

      if (!response.ok) {
        // If backend didn't find (404) or other error, try a fallback: remove extra spaces & try again.
        safeLog('Primary fetch failed with', response.status);
        if (response.status === 404) {
          // try with trimmed lower-case in case backend has that variant
          const fallbackUrl = `https://sanghamitra-learnworld.vercel.app/api/iitm-ct-questions?topic=${encodeURIComponent(topic.trim())}`;
          const fallbackResp = await fetch(fallbackUrl, { credentials: 'include' });
          if (!fallbackResp.ok) throw new Error(`HTTP error! status: ${fallbackResp.status}`);
          const fallbackData = await fallbackResp.json();
          questions = fallbackData.questions || fallbackData;
        } else {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
      } else {
        const data = await response.json();
        // API might return metadata with questions or raw array
        if (data.resetAvailable) {
          // Let caller handle reset flow (UI)
          return data;
        }
        questions = data.questions || data;
      }

      if (!questions || questions.length === 0) {
        throw new Error('No questions found for the selected topic');
      }

      // Normalize question fields if needed
      questions = questions.map(q => ({
        ...q,
        difficulty: q.difficulty || 'medium',
        points: typeof q.points === 'number' ? q.points : (q.points ? Number(q.points) : 1)
      }));

      safeLog(`Loaded ${questions.length} questions`);
      return true;
    } catch (error) {
      console.error('Error loading CT questions:', error);
      alert('Failed to load quiz questions. Please refresh and try again.');
      return false;
    }
  }

  // ----- Anti-cheating (with developer-tools features removed) -----
  function initializeAntiCheating() {
    // Prevent context menu (optional)
    document.addEventListener('contextmenu', function(e) {
      // you can choose to remove this listener if right-click should be allowed
      e.preventDefault();
      recordCheatingAttempt('right_click');
      return false;
    });

    // Prevent text selection as soft anti-cheat
    document.onselectstart = function() {
      recordCheatingAttempt('text_selection');
      return false;
    };

    // Detect switching away from tab/window
    window.addEventListener('blur', function() {
      if (isQuizActive) {
        document.body.classList.add('blurred');
        const overlay = document.getElementById('warningOverlay');
        if (overlay) overlay.style.display = 'flex';
        recordCheatingAttempt('window_blur');
      }
    });

    window.addEventListener('focus', function() {
      document.body.classList.remove('blurred');
      const overlay = document.getElementById('warningOverlay');
      if (overlay) overlay.style.display = 'none';
    });
  }

  function recordCheatingAttempt(type) {
    cheatingAttempts++;
    console.warn(`Cheating attempt #${cheatingAttempts}: ${type}`);

    if (username && email) {
      fetch('https://sanghamitra-learnworld.vercel.app/api/log-ct-cheating', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          username,
          email,
          cheatingType: type,
          timestamp: new Date(),
          currentQuestion: currentQuestionIndex + 1
        })
      }).catch(err => console.error('Failed to log cheating attempt:', err));
    }

    // Soft enforcement: if too many attempts, auto-submit
    if (cheatingAttempts >= 10) {
      alert('Multiple suspicious activities detected. Quiz will be auto-submitted for review.');
      submitQuiz();
    }
  }

  // ----- Rendering -----
  function renderCurrentQuestion() {
    const container = document.getElementById('questionContainer');
    if (!container) return;
    const question = questions[currentQuestionIndex];
    if (!question) {
      container.innerHTML = '<p>No question found.</p>';
      return;
    }

    container.innerHTML = '';

    // Create split layout
    const splitDiv = document.createElement('div');
    splitDiv.className = 'question-split';

    // LEFT SIDE - Question
    const questionSide = document.createElement('div');
    questionSide.className = 'question-side';

    let parentStatementHTML = '';
    if (question.parent_statement) {
      parentStatementHTML = `
        <div class="parent-statement">
          <strong>üìã Context:</strong><br>
          ${escapeHtml(question.parent_statement)}
        </div>
      `;
    }

    let datasetHTML = '';
    if (question.dataset && question.dataset !== 'None') {
      datasetHTML = `<span class="dataset-badge">üìä Dataset: ${escapeHtml(question.dataset)}</span>`;
    }

    questionSide.innerHTML = `
      <div class="question-header">
        <div class="question-number">${escapeHtml(question.question_number)}</div>
        <div>
          <span class="difficulty-badge difficulty-${escapeHtml(question.difficulty)}">
            ${escapeHtml(question.difficulty)}
          </span>
          <span class="points-badge">‚≠ê ${escapeHtml(question.points)}</span>
        </div>
      </div>
      ${parentStatementHTML}
      <div class="question-text">${escapeHtml(question.question_text)}</div>
      ${datasetHTML}
    `;

    // RIGHT SIDE - Answers
    const answerSide = document.createElement('div');
    answerSide.className = 'answer-side';

    let answerInstructionText = '';
    if (question.type === 'mcq') {
      answerInstructionText = 'üìå Select ONE answer';
    } else if (question.type === 'msq') {
      answerInstructionText = 'üìå Select ALL that apply';
    } else if (question.type === 'numeric') {
      answerInstructionText = 'üìå Enter numeric answer';
    }

    let optionsHtml = '';
    if (question.type === 'mcq') {
      optionsHtml = `<div class="options">` +
        question.options.map((option, optIndex) => `
          <div class="option" onclick="(function(e){ window.ctQuiz.selectOption(e, ${currentQuestionIndex}, '${escapeJs(option)}', 'radio') })(event)">
            <input type="radio" name="q${currentQuestionIndex}" value="${escapeHtml(option)}" id="q${currentQuestionIndex}_${optIndex}">
            <label for="q${currentQuestionIndex}_${optIndex}">${escapeHtml(option)}</label>
          </div>
        `).join('') + `</div>`;
    } else if (question.type === 'msq') {
      optionsHtml = `<div class="options">` +
        question.options.map((option, optIndex) => `
          <div class="option" onclick="(function(e){ window.ctQuiz.selectOption(e, ${currentQuestionIndex}, '${escapeJs(option)}', 'checkbox') })(event)">
            <input type="checkbox" name="q${currentQuestionIndex}" value="${escapeHtml(option)}" id="q${currentQuestionIndex}_${optIndex}">
            <label for="q${currentQuestionIndex}_${optIndex}">${escapeHtml(option)}</label>
          </div>
        `).join('') + `</div>`;
    } else if (question.type === 'numeric') {
      const placeholder = "Enter your numeric answer";
      optionsHtml = `
        <div class="input-container">
          <input type="text"
                 class="numeric-input"
                 placeholder="${placeholder}"
                 oninput="(function(e){ window.ctQuiz.handleNumericInput(${currentQuestionIndex}, e.target.value) })(event)"
                 autocomplete="off">
          <div class="format-help">Enter a numeric value</div>
        </div>
      `;
    }

    answerSide.innerHTML = `
      <div class="answer-header">
        <h3>Your Answer</h3>
        <p class="answer-instruction">${answerInstructionText}</p>
      </div>
      ${optionsHtml}
    `;

    splitDiv.appendChild(questionSide);
    splitDiv.appendChild(answerSide);
    container.appendChild(splitDiv);

    restoreAnswer();           // restore a saved answer for this question index (if any)
    updateAnswerStatus();
    updateProgress();
  }

  // ----- Helpers: escaping to avoid HTML injection -----
  function escapeHtml(text) {
    if (text === undefined || text === null) return '';
    return String(text)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function escapeJs(text) {
    if (text === undefined || text === null) return '';
    return String(text).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
  }

  // ----- Restore / Answer state management -----
  function restoreAnswer() {
    const question = questions[currentQuestionIndex];
    const savedAnswer = userAnswers[currentQuestionIndex];

    if (!savedAnswer) return;

    if (question.type === 'mcq') {
      const option = document.querySelector(`input[name="q${currentQuestionIndex}"][value="${CSS.escape(savedAnswer)}"]`);
      if (option) {
        option.checked = true;
        const optWrap = option.closest('.option');
        if (optWrap) optWrap.classList.add('selected');
      } else {
        // fallback: search by value match ignoring HTML escaping
        const all = document.querySelectorAll(`input[name="q${currentQuestionIndex}"]`);
        all.forEach(inp => {
          if ((inp.value||'').toString().trim().toLowerCase() === savedAnswer.toString().trim().toLowerCase()) {
            inp.checked = true;
            const wrap = inp.closest('.option');
            if (wrap) wrap.classList.add('selected');
          }
        });
      }
    } else if (question.type === 'msq' && Array.isArray(savedAnswer)) {
      savedAnswer.forEach(answer => {
        const option = document.querySelector(`input[name="q${currentQuestionIndex}"][value="${CSS.escape(answer)}"]`);
        if (option) {
          option.checked = true;
          const optWrap = option.closest('.option');
          if (optWrap) optWrap.classList.add('selected');
        } else {
          // fallback match by lower-case
          const all = document.querySelectorAll(`input[name="q${currentQuestionIndex}"]`);
          all.forEach(inp => {
            if ((inp.value||'').toString().trim().toLowerCase() === answer.toString().trim().toLowerCase()) {
              inp.checked = true;
              const wrap = inp.closest('.option');
              if (wrap) wrap.classList.add('selected');
            }
          });
        }
      });
    } else if (question.type === 'numeric') {
      const input = document.querySelector('.numeric-input');
      if (input) input.value = savedAnswer;
    }
  }

  function updateAnswerStatus() {
    const statusSpan = document.getElementById('answeredStatus');
    if (!statusSpan) return;
    const hasAnswer = userAnswers[currentQuestionIndex] !== undefined;
    if (hasAnswer) {
      statusSpan.textContent = '‚úì Answered';
      statusSpan.className = 'status-answered';
    } else {
      statusSpan.textContent = '‚ö† Unanswered';
      statusSpan.className = 'status-unanswered';
    }
  }

  function updateProgress() {
    const progressElem = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const questionStatus = document.getElementById('questionStatus');

    if (!questions || questions.length === 0) return;

    const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
    if (progressElem) progressElem.style.width = `${progress}%`;
    if (progressText) progressText.textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
    if (questionStatus) questionStatus.textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    if (prevBtn) prevBtn.disabled = currentQuestionIndex === 0;

    if (nextBtn) {
      if (currentQuestionIndex === questions.length - 1) {
        nextBtn.textContent = 'Finish ‚úì';
        nextBtn.onclick = () => {
          document.getElementById('quizContainer').scrollIntoView({ behavior: 'smooth', block: 'end' });
        };
      } else {
        nextBtn.textContent = 'Next ‚Üí';
        nextBtn.onclick = nextQuestion;
      }
    }
  }

  // ----- Navigation & timing -----
  function nextQuestion() {
    if (currentQuestionIndex < questions.length - 1) {
      trackQuestionTime();
      currentQuestionIndex++;
      renderCurrentQuestion();
      startAutosave();
    }
  }

  function previousQuestion() {
    if (currentQuestionIndex > 0) {
      trackQuestionTime();
      currentQuestionIndex--;
      renderCurrentQuestion();
      startAutosave();
    }
  }

  function trackQuestionTime() {
    if (questionStartTime) {
      const timeSpent = Math.floor((new Date() - questionStartTime) / 1000);
      // store timeSpent under the index that was active BEFORE moving to next question
      questionTimes[currentQuestionIndex] = (questionTimes[currentQuestionIndex] || 0) + timeSpent;
    }
    questionStartTime = new Date();
  }

  // ----- Answer handlers (exposed on window.ctQuiz) -----
  function selectOption(event, questionIndex, value, type) {
    // ensure event exists
    if (event && event.stopPropagation) event.stopPropagation();

    if (type === 'radio') {
      userAnswers[questionIndex] = value.toString().trim();
      // visually mark selection
      const options = document.querySelectorAll(`input[name="q${questionIndex}"]`);
      options.forEach(opt => {
        const wrap = opt.closest('.option');
        if (wrap) wrap.classList.remove('selected');
      });
      // find the clicked input (closest .option -> input)
      const clicked = (event && event.target) ? event.target : null;
      // try to locate the input inside clicked .option
      if (clicked) {
        const wrap = clicked.closest && clicked.closest('.option');
        if (wrap) {
          wrap.classList.add('selected');
          const inp = wrap.querySelector('input');
          if (inp) inp.checked = true;
        }
      }
    } else if (type === 'checkbox') {
      // toggle selection based on actual input checked state
      if (!Array.isArray(userAnswers[questionIndex])) userAnswers[questionIndex] = [];
      const wrap = event && event.target && event.target.closest && event.target.closest('.option');
      const checkbox = wrap ? wrap.querySelector('input[type="checkbox"]') : null;
      const trimmedValue = value.toString().trim();

      if (checkbox && checkbox.checked) {
        if (!userAnswers[questionIndex].includes(trimmedValue)) {
          userAnswers[questionIndex].push(trimmedValue);
        }
        if (wrap) wrap.classList.add('selected');
      } else {
        userAnswers[questionIndex] = userAnswers[questionIndex].filter(ans => ans !== trimmedValue);
        if (wrap) wrap.classList.remove('selected');
        if (userAnswers[questionIndex].length === 0) {
          delete userAnswers[questionIndex];
        }
      }
    }

    updateAnswerStatus();
    saveProgressToLocal();
  }

  function handleNumericInput(questionIndex, value) {
    const trimmedValue = (value || '').toString().trim();
    if (trimmedValue !== '') {
      userAnswers[questionIndex] = trimmedValue;
    } else {
      delete userAnswers[questionIndex];
    }
    updateAnswerStatus();
    saveProgressToLocal();
  }

  // Expose a few functions to the global for onclick inline use
  window.ctQuiz = {
    selectOption,
    handleNumericInput
  };

  // ----- Submit quiz -----
  async function submitQuiz() {
    const confirmSubmit = confirm(
      `Ready to Submit CT Quiz for "${topic}"?\n\n` +
      `Please make sure you have reviewed all your answers before submitting.\n` +
      `Once submitted, you won't be able to make changes.\n\n` +
      `Are you ready to submit?`
    );

    if (!confirmSubmit) return;

    if (!username || !email) {
      alert("Error: User session data not found. Please log in.");
      return;
    }

    trackQuestionTime();
    isQuizActive = false;
    stopAutosave();
    const quizEndTime = new Date();
    const totalTimeTaken = Math.floor((quizEndTime - quizStartTime) / 1000);

    // Calculate scores
    let totalPoints = 0;
    let earnedPoints = 0;
    const questionResults = [];
    const difficultyBreakdown = {
      easy: { attempted: 0, correct: 0, points: 0 },
      medium: { attempted: 0, correct: 0, points: 0 },
      hard: { attempted: 0, correct: 0, points: 0 }
    };

    questions.forEach((question, index) => {
      const userAnswer = userAnswers[index];
      totalPoints += question.points;

      let isCorrect = false;

      if (question.type === 'mcq') {
        const normalizeAnswer = (ans) => (ans || '').toString().trim().toLowerCase();
        isCorrect = normalizeAnswer(userAnswer) === normalizeAnswer(question.correct_answer);
      } else if (question.type === 'msq') {
        if (Array.isArray(userAnswer) && Array.isArray(question.correct_answer)) {
          const normalizeArray = (arr) => arr.map(item => item.toString().trim().toLowerCase()).sort();
          const userNorm = normalizeArray(userAnswer);
          const correctNorm = normalizeArray(question.correct_answer);
          isCorrect = userNorm.length === correctNorm.length &&
                     userNorm.every((ans, idx) => ans === correctNorm[idx]);
        }
      } else if (question.type === 'numeric') {
        const userNum = parseFloat((userAnswer || '').toString().replace(/[^\d.-]/g, ''));
        const correctNum = parseFloat((question.correct_answer || '').toString().replace(/[^\d.-]/g, ''));
        if (!isNaN(userNum) && !isNaN(correctNum)) {
          const tolerance = Math.abs(correctNum) * 0.01 || 0.01;
          isCorrect = Math.abs(userNum - correctNum) <= tolerance;
        }
      }

      if (isCorrect) {
        earnedPoints += question.points;
      }

      // Update difficulty breakdown
      const diff = question.difficulty || 'medium';
      if (!difficultyBreakdown[diff]) difficultyBreakdown[diff] = { attempted: 0, correct: 0, points: 0 };
      difficultyBreakdown[diff].attempted++;
      if (isCorrect) {
        difficultyBreakdown[diff].correct++;
        difficultyBreakdown[diff].points += question.points;
      }

      questionResults.push({
        questionId: question._id,
        questionNumber: question.question_number,
        questionText: question.question_text,
        difficulty: diff,
        points: question.points,
        pointsAwarded: isCorrect ? question.points : 0,
        maxPoints: question.points,
        userAnswer: userAnswer ? (Array.isArray(userAnswer) ? userAnswer.join(', ') : userAnswer.toString()) : 'No answer provided',
        correctAnswer: Array.isArray(question.correct_answer) ? question.correct_answer.join(', ') : question.correct_answer ? question.correct_answer.toString() : '',
        explanation: question.explanation || '',
        isCorrect: isCorrect,
        timeTaken: questionTimes[index] || 0
      });
    });

    const percent = totalPoints ? Math.round((earnedPoints / totalPoints) * 100) : 0;
    const quizData = {
      topic,
      quizType: 'ct_week1',
      score: earnedPoints,
      totalPoints,
      earnedPoints,
      totalQuestions: questions.length,
      correctAnswers: questionResults.filter(q => q.isCorrect).length,
      percentage: percent,
      difficultyBreakdown,
      questionResults,
      startTime: quizStartTime,
      endTime: quizEndTime,
      totalTimeTaken,
      isCompleted: true
    };

    try {
      // UI toggles
      const submitText = document.getElementById('submitText');
      const submitLoading = document.getElementById('submitLoading');
      const submitBtn = document.getElementById('submitBtn');
      if (submitText) submitText.style.display = 'none';
      if (submitLoading) submitLoading.style.display = 'inline-block';
      if (submitBtn) submitBtn.disabled = true;

      safeLog('Submitting CT quiz data', { email, username, quizData });

      const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/iitm-ct-scores', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          email,
          username,
          quizData
        })
      });

      if (response.ok) {
        safeLog('CT quiz submitted successfully');
        clearSavedProgress();
        displayDetailedResults(quizData);
      } else {
        const errorText = await response.text();
        console.error('Failed to submit CT quiz:', errorText);
        alert('Failed to submit quiz. Please try again.');
        if (submitText) submitText.style.display = 'inline';
        if (submitLoading) submitLoading.style.display = 'none';
        if (submitBtn) submitBtn.disabled = false;
        startAutosave();
        return;
      }
    } catch (error) {
      console.error('Error submitting CT quiz:', error);
      alert('Error submitting quiz. Please check your connection and try again.');
      const submitText = document.getElementById('submitText');
      const submitLoading = document.getElementById('submitLoading');
      const submitBtn = document.getElementById('submitBtn');
      if (submitText) submitText.style.display = 'inline';
      if (submitLoading) submitLoading.style.display = 'none';
      if (submitBtn) submitBtn.disabled = false;
      startAutosave();
      return;
    }
  }

  // ----- Display results -----
  function displayDetailedResults(quizData) {
    const quizContainer = document.getElementById('quizContainer');
    if (quizContainer) quizContainer.style.display = 'none';

    const resultsContainer = document.getElementById('resultsContainer');
    if (!resultsContainer) return;
    resultsContainer.style.display = 'block';

    const scoreDisplay = document.querySelector('.score-display');
    if (scoreDisplay) {
      scoreDisplay.innerHTML = `
        <h2>${quizData.earnedPoints}/${quizData.totalPoints} Points (${quizData.percentage}%)</h2>
        <p>üéâ Quiz Completed Successfully!</p>
        <div style="margin-top: 20px; display: flex; justify-content: space-around; text-align: center;">
          <div>
            <strong>Easy Questions</strong><br>
            ${quizData.difficultyBreakdown.easy.correct}/${quizData.difficultyBreakdown.easy.attempted}
            <br><small>${quizData.difficultyBreakdown.easy.points} points</small>
          </div>
          <div>
            <strong>Medium Questions</strong><br>
            ${quizData.difficultyBreakdown.medium.correct}/${quizData.difficultyBreakdown.medium.attempted}
            <br><small>${quizData.difficultyBreakdown.medium.points} points</small>
          </div>
          <div>
            <strong>Hard Questions</strong><br>
            ${quizData.difficultyBreakdown.hard.correct}/${quizData.difficultyBreakdown.hard.attempted}
            <br><small>${quizData.difficultyBreakdown.hard.points} points</small>
          </div>
        </div>
        <p style="margin-top: 15px; font-size: 0.9em;">
          ‚è±Ô∏è Time Taken: ${Math.floor(quizData.totalTimeTaken / 60)}m ${quizData.totalTimeTaken % 60}s
        </p>
      `;
    }

    // Add detailed review
    const reviewDiv = document.createElement('div');
    reviewDiv.style.cssText = `
      margin-top: 30px;
      text-align: left;
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    `;
    reviewDiv.innerHTML = `
      <h3 style="text-align: center; margin-bottom: 25px; color: #333;">üìä Question Review</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 15px;">
      ${quizData.questionResults.map(result => `
        <div style="border: 2px solid ${result.isCorrect ? '#28a745' : '#dc3545'}; 
                    border-radius: 8px; 
                    padding: 15px; 
                    background: ${result.isCorrect ? '#f8fff9' : '#fff8f8'};">
          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <span style="background: ${result.isCorrect ? '#28a745' : '#dc3545'}; 
                        color: white; 
                        padding: 4px 8px; 
                        border-radius: 50%; 
                        margin-right: 10px; 
                        font-weight: bold;">
              ${escapeHtml(result.questionNumber)}
            </span>
            <span style="font-weight: bold; color: ${result.isCorrect ? '#28a745' : '#dc3545'};">
              ${result.isCorrect ? '‚úì CORRECT' : '‚úó INCORRECT'}
            </span>
            <span style="margin-left: auto; background: ${getDifficultyColor(result.difficulty)}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px;">
              ${escapeHtml(result.difficulty.toUpperCase())}
            </span>
          </div>
          <div style="margin-bottom: 10px; line-height: 1.4; font-size: 0.95em;">
            <strong>Question:</strong> ${escapeHtml(result.questionText)}
          </div>
          <div style="margin-bottom: 8px;">
            <strong>Your Answer:</strong> 
            <span style="color: ${result.isCorrect ? '#28a745' : '#dc3545'}; font-weight: bold;">
              ${escapeHtml(result.userAnswer)}
            </span>
          </div>
          <div style="margin-bottom: 8px;">
            <strong>Correct Answer:</strong> 
            <span style="color: #28a745; font-weight: bold;">
              ${escapeHtml(result.correctAnswer)}
            </span>
          </div>
          ${result.explanation ? `
            <div style="margin-bottom: 8px; padding: 10px; background: #f0f8ff; border-radius: 4px;">
              <strong>üí° Explanation:</strong><br>
              <span style="color: #333; font-size: 0.9em;">
                ${escapeHtml(result.explanation)}
              </span>
            </div>
          ` : ''}
          <div style="font-size: 0.9em; color: #666; margin-top: 8px;">
            ‚è±Ô∏è ${escapeHtml(result.timeTaken)}s | ‚≠ê ${escapeHtml(result.pointsAwarded)}/${escapeHtml(result.maxPoints)} pts
          </div>
        </div>
      `).join('')}
      </div>
    `;
    resultsContainer.appendChild(reviewDiv);
  }

  function getDifficultyColor(difficulty) {
    switch (difficulty) {
      case 'easy': return '#28a745';
      case 'medium': return '#ffc107';
      case 'hard': return '#dc3545';
      default: return '#6c757d';
    }
  }

  // ----- Reset user progress (complete) -----
  async function resetUserProgress() {
    try {
      if (!email) {
        alert('Please login to reset progress.');
        return false;
      }

      const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/reset-ct-progress', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email })
      });

      if (response.ok) {
        alert('CT progress reset successfully! You can now retake all questions.');
        clearSavedProgress();
        userAnswers = {};
        questionTimes = {};
        currentQuestionIndex = 0;
        return true;
      } else {
        const errorText = await response.text();
        console.error('Failed to reset progress:', errorText);
        alert('Failed to reset progress. Please try again.');
        return false;
      }
    } catch (error) {
      console.error('Error resetting CT progress:', error);
      alert('Error connecting to server while resetting progress.');
      return false;
    }
  }

  // ----- Init / boot -----
  async function initializeQuiz() {
    try {
      // Setup anti-cheating (without devtools blocks)
      initializeAntiCheating();

      // session check
      const sessionValid = await fetchSessionInfo();
      if (!sessionValid) return;

      // Try to restore saved progress if present
      loadSavedProgress();

      // Load questions
      const qRes = await loadQuestions();
      // If API returns resetAvailable metadata, handle it
      if (qRes && typeof qRes === 'object' && qRes.resetAvailable) {
        const resetConfirm = confirm(
          `You have completed all available CT questions!\n\n` +
          `Total questions in pool: ${qRes.totalQuestionsInPool}\n\n` +
          `Would you like to reset your progress to start over?`
        );
        if (resetConfirm) {
          const ok = await resetUserProgress();
          if (ok) {
            // reload questions after reset
            await sleep(300);
            await initializeQuiz();
            return;
          } else {
            alert('Reset failed. Please try again later.');
            return;
          }
        } else {
          alert('No new questions available. Please contact admin or try again later.');
          window.location.href = 'iitm_ct.html';
          return;
        }
      } else if (qRes !== true) {
        // if loadQuestions returned false, we already alerted
        return;
      }

      // Start times
      quizStartTime = new Date();
      questionStartTime = new Date();
      isQuizActive = true;

      // Show UI containers
      const loadingScreen = document.getElementById('loadingScreen');
      const quizContainer = document.getElementById('quizContainer');
      if (loadingScreen) loadingScreen.style.display = 'none';
      if (quizContainer) quizContainer.style.display = 'block';

      // If we had saved progress, ensure index is within bounds
      if (currentQuestionIndex >= questions.length) currentQuestionIndex = 0;

      // Render and start autosave
      renderCurrentQuestion();
      startAutosave();

      // Enter fullscreen if possible (non-blocking)
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(err => {
          safeLog('Fullscreen request failed:', err);
        });
      }
    } catch (error) {
      console.error('Error initializing quiz:', error);
      alert('Error starting quiz. Please try again.');
    }
  }

  // ----- Other UI helpers -----
  function goback() {
    userAnswers = {};
    questionTimes = {};
    clearSavedProgress();
    window.location.href = 'iitm_ct.html';
  }

  // ----- DOM events binding for nav buttons in case they are normal buttons -----
  document.addEventListener('DOMContentLoaded', () => {
    // Bind next/prev/submit in case they exist in DOM
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const resetBtn = document.getElementById('resetProgressBtn');

    if (prevBtn) prevBtn.addEventListener('click', previousQuestion);
    if (nextBtn) nextBtn.addEventListener('click', nextQuestion);
    if (submitBtn) submitBtn.addEventListener('click', submitQuiz);
    if (resetBtn) resetBtn.addEventListener('click', async () => {
      const ok = confirm('Are you sure you want to reset your local saved progress? This will not reset server progress.');
      if (!ok) return;
      clearSavedProgress();
      userAnswers = {};
      questionTimes = {};
      currentQuestionIndex = 0;
      renderCurrentQuestion();
      alert('Local progress cleared.');
    });

    // Kick off initialization
    initializeQuiz();
  });

  // ----- End of IIFE -----
})();
</script>
