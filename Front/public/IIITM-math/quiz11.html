<!DOCTYPE html>      
<html lang="en">    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Limits, Continuity and Differentiation Quiz</title>

    <!-- Add this right after <title> tag -->
<script>
window.MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
    },
    options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    svg: {
        fontCache: 'global'
    },
    startup: {
        ready: () => {
            console.log('MathJax is loaded and ready');
            MathJax.startup.defaultReady();
        }
    }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
   
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* MathJax styling */
       /* MathJax styling */
.MathJax, .MathJax_SVG, .MathJax_Display, mjx-container {
    max-width: 100% !important;
    overflow-x: auto !important;
    display: inline-block !important;
}

mjx-container[jax="SVG"] {
    direction: ltr;
    display: inline-block;
    font-style: normal;
    font-weight: normal;
    line-height: normal;
    font-size: 115%;
    text-indent: 0;
    text-align: left;
    text-transform: none;
    letter-spacing: normal;
    word-spacing: normal;
    white-space: nowrap;
    float: none;
    max-width: none;
    max-height: none;
    min-width: 0;
    min-height: 0;
    border: 0;
    margin: 0;
    padding: 2px 0;
}

        .question-text mjx-container {
            display: inline-block !important;
            margin: 0 2px !important;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .header p { font-size: 1.1rem; opacity: 0.9; }

        .user-form {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 600; }
        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
        }
        /* Anti-cheating CSS */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            -webkit-print-color-adjust: exact;
            pointer-events: auto;
        }
        
        /* Disable context menu */
        .no-context {
            pointer-events: none;
        }
        
        /* Hide scrollbars to prevent inspection */
        ::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        
        /* Blur content when window loses focus */
        body.blurred {
            filter: blur(5px);
            pointer-events: none;
        }
        
        /* Warning overlay */
        .warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(220, 53, 69, 0.95);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            font-size: 2rem;
            text-align: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .btn:disabled { 
            background: #6c757d; 
            cursor: not-allowed; 
            transform: none; 
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-container {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-weight: 600;
        }

        .question-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }

        .btn-nav {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-nav:hover:not(:disabled) {
            background: #545b62;
            transform: translateY(-1px);
        }

        .btn-nav:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-next {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-next:hover:not(:disabled) {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }

        .question-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }

        .status-answered {
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .status-unanswered {
            background: #dc3545;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

                /* Better MathJax display */
        .question-text {
            font-size: 1.1rem;
            line-height: 2 !important;
            color: #333;
            margin-bottom: 20px;
            white-space: normal;
            word-wrap: break-word;
        }

        .question-text mjx-container {
            display: inline !important;
            margin: 0 3px !important;
            vertical-align: middle;
        }

        /* Results page math rendering */
        .results-container mjx-container {
            display: inline !important;
            margin: 0 3px !important;
            vertical-align: middle;
        }

        .quiz-container { padding: 30px; display: none; }

        .question-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
        }

        .question-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-number {
            background: #667eea;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 15px;
        }

        .question-text {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #333;
            margin-bottom: 20px;
            white-space: pre-line;
        }

        .options { display: flex; flex-direction: column; gap: 12px; }

        .option {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover { border-color: #667eea; background: #f0f8ff; }
        .option.selected { border-color: #667eea; background: #e3f2fd; }

        .numeric-input {
            width: 200px;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
        }

        .results-container {
            display: none;
            padding: 30px;
            text-align: center;
            max-height: 80vh;
            overflow-y: auto;
        }

        .score-display {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .score-display h2 { font-size: 2.5rem; margin-bottom: 10px; }
        .hidden { display: none; }
        
        /* Difficulty badges */
        .difficulty-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            text-transform: uppercase;
        }

        .difficulty-easy { background: #d4edda; color: #155724; }
        .difficulty-medium { background: #fff3cd; color: #856404; }
        .difficulty-hard { background: #f8d7da; color: #721c24; }
        /* Results review styling */
        .results-container h3 {
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        @media (max-width: 768px) {
            .results-container {
                padding: 15px;
            }
            
            .score-display {
                padding: 20px;
            }
            
            .score-display h2 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Limits, Continuity and Differentiation Quiz</h1>
            <p>Test your knowledge of limits, continuity and differentiation with 30 comprehensive questions</p>
        </div>

        <!-- Quiz Container -->
        <div id="quizContainer" class="quiz-container" style="display: none;">
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Question 1 of 30</div>
            </div>
            
            <div id="questionContainer"></div>
            
            <div class="question-navigation">
                <button class="btn-nav" id="prevBtn" onclick="previousQuestion()" disabled>Previous</button>
                <div class="question-status">
                    <span id="questionStatus">Question 1 of 30</span>
                    <span id="answeredStatus" class="status-unanswered">Unanswered</span>
                </div>
                <button class="btn-nav btn-next" id="nextBtn" onclick="nextQuestion()">Next</button>
            </div>
            
            <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 2px solid #667eea;">
                <button class="btn" onclick="submitQuiz()" id="submitBtn">
                    <span id="submitText">Submit Limits, Continuity and Differentiation Quiz</span>
                    <span id="submitLoading" class="loading" style="display: none;"></span>
                </button>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="quiz-container" style="text-align: center; padding: 60px;">
            <div class="loading" style="width: 40px; height: 40px; margin: 0 auto 20px;"></div>
            <h3>Loading Limits, Continuity and Differentiation Quiz...</h3>
            <p>Verifying your session and preparing questions</p>
        </div>

        <!-- Results -->
        <div id="resultsContainer" class="results-container">
            <div class="score-display">
                <h2 id="finalScore">0/30</h2>
                <p>Quiz Completed Successfully!</p>
            </div>
            <button class="btn" onclick="goback()">Home Page</button>
        </div>
    </div>
   
    <!-- Anti-cheating warning overlay -->
    <div id="warningOverlay" class="warning-overlay">
        <div>
            <h2>CHEATING ATTEMPT DETECTED</h2>
            <p>Please return to the quiz window</p>
            <p>Your activity is being monitored</p>
        </div>
    </div>

    <script>
        // Enhanced Answer validation utility with flexible infinity support
        const answerNormalizer = {
            normalizeInterval: (answer) => {
                return (answer || '').toString().trim()
                    .replace(/\s+/g, '')  // Remove all spaces
                    .replace(/infinity|Infinity|INFINITY|‚àû/gi, 'inf') // Convert all infinity variations to 'inf'
                    .replace(/\+inf/gi, 'inf') // Convert +inf to inf
                    .replace(/-\s*inf/gi, '-inf') // Ensure -inf format
                    .replace(/\[/g, '[')
                    .replace(/\]/g, ']')
                    .replace(/\(/g, '(')
                    .replace(/\)/g, ')')
                    .toLowerCase();
            },
            
            normalizeCoordinate: (coord) => {
                return (coord || '').toString().trim()
                    .replace(/\s+/g, '')  // Remove all spaces
                    .replace(/[()]/g, '')  // Remove parentheses for comparison
                    .toLowerCase();
            },
            
            normalizeEquation: (eq) => {
                return (eq || '').toString()
                    .replace(/\s+/g, '')  // Remove all spaces
                    .replace(/\*\*/g, '^')  // Convert ** to ^
                    .replace(/\^/g, '^')
                    .replace(/\+\-/g, '-')
                    .replace(/\-\+/g, '-')
                    .replace(/log/gi, 'log')  // Normalize log functions
                    .replace(/ln/gi, 'ln')    // Normalize natural log
                    .toLowerCase();
            },
            
            normalizeNumeric: (num) => {
                const str = (num || '').toString().trim().toLowerCase();
                
                // Handle positive infinity variations
                if (str === 'inf' || str === 'infinity' || str === '+inf' || str === '+infinity' || str === '‚àû' || str === '+‚àû') {
                    return Infinity;
                }
                
                // Handle negative infinity variations  
                if (str === '-inf' || str === '-infinity' || str === '-‚àû' || str === '-inf' || str === '-infinity') {
                    return -Infinity;
                }
                
                // Handle regular numbers
                const cleaned = str.replace(/[^\d.-]/g, '');
                return cleaned ? parseFloat(cleaned) : NaN;
            },
            
            // New method to normalize any answer type generically
            normalizeAnswer: (answer, questionType) => {
                if (!answer) return '';
                
                const str = answer.toString().trim();
                
                if (questionType === 'interval_input') {
                    return answerNormalizer.normalizeInterval(str);
                } else if (questionType === 'numeric' || questionType === 'numeric_input') {
                    const normalized = answerNormalizer.normalizeNumeric(str);
                    return isFinite(normalized) ? normalized.toString() : 
                           normalized === Infinity ? 'inf' : 
                           normalized === -Infinity ? '-inf' : str;
                } else if (questionType === 'coordinate_input') {
                    return answerNormalizer.normalizeCoordinate(str);
                } else if (questionType === 'equation_input') {
                    return answerNormalizer.normalizeEquation(str);
                } else {
                    return str.toLowerCase();
                }
            }
        };

        let userAnswers = {};
        let currentUser = {};
        let username = null;
        let email = null;
        let currentQuestionIndex = 0;
        let quizStartTime = null;
        let questionStartTime = null;
        let questionTimes = {}; // Track time per question
        let questions = []; // Add this line to declare the questions array globally

        // Anti-cheating variables
        let cheatingAttempts = 0;
        let isQuizActive = false;
        let devToolsWarned = false;
        
        // Anti-cheating initialization
        function initializeAntiCheating() {
            // Disable right-click
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                recordCheatingAttempt('right_click');
                return false;
            });
            
            // Disable common keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Disable F12, Ctrl+Shift+I, Ctrl+U, Ctrl+S, Print Screen
                if (e.keyCode === 123 || // F12
                    (e.ctrlKey && e.shiftKey && e.keyCode === 73) || // Ctrl+Shift+I
                    (e.ctrlKey && e.keyCode === 85) || // Ctrl+U
                    (e.ctrlKey && e.keyCode === 83) || // Ctrl+S
                    e.keyCode === 44) { // Print Screen
                    e.preventDefault();
                    recordCheatingAttempt('keyboard_shortcut');
                    return false;
                }
                
                // Disable Ctrl+A, Ctrl+C, Ctrl+V
                if (e.ctrlKey && (e.keyCode === 65 || e.keyCode === 67 || e.keyCode === 86)) {
                    e.preventDefault();
                    recordCheatingAttempt('copy_attempt');
                    return false;
                }
            });
            
            // Detect developer tools
            let devtools = {open: false, orientation: null};
            const threshold = 160;
            
            setInterval(function() {
                if (window.outerHeight - window.innerHeight > threshold || 
                    window.outerWidth - window.innerWidth > threshold) {
                    if (!devtools.open) {
                        devtools.open = true;
                        recordCheatingAttempt('developer_tools');
                        if (!devToolsWarned) {
                            alert('Developer tools detected! This attempt has been logged.');
                            devToolsWarned = true;
                        }
                    }
                } else {
                    devtools.open = false;
                }
            }, 500);
            
            // Detect window focus changes
           // window.addEventListener('blur', function() {
              //  if (isQuizActive) {
              //      document.body.classList.add('blurred');
              //      document.getElementById('warningOverlay').style.display = 'flex';
              //      recordCheatingAttempt('window_blur');
             //   }
          //  });
            
            window.addEventListener('focus', function() {
                document.body.classList.remove('blurred');
                document.getElementById('warningOverlay').style.display = 'none';
            });
            
            // Prevent text selection
            document.onselectstart = function() {
                recordCheatingAttempt('text_selection');
                return false;
            };
            
            // Disable drag
            document.ondragstart = function() {
                return false;
            };
            
            // Monitor for screenshot attempts (limited effectiveness)
            document.addEventListener('keyup', function(e) {
                if (e.keyCode === 44) { // Print Screen released
                    recordCheatingAttempt('screenshot_attempt');
                    alert('Screenshot attempt detected and logged!');
                }
            });
        }
        
        // Record cheating attempts
        function recordCheatingAttempt(type) {
            cheatingAttempts++;
            console.warn(`Cheating attempt #${cheatingAttempts}: ${type}`);
            
            // FIXED: Correct API endpoint for logging cheating
            if (username && email) {
                fetch('https://sanghamitra-learnworld.vercel.app/api/log-cheating', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: username,
                        email: email,
                        cheatingType: type,
                        timestamp: new Date(),
                        currentQuestion: currentQuestionIndex + 1
                    })
                }).catch(err => console.error('Failed to log cheating attempt:', err));
            }
            
            // Auto-submit quiz after too many attempts
            if (cheatingAttempts >= 5) {
                alert('Too many suspicious activities detected. Quiz will be auto-submitted.');
                submitQuiz();
            }
        }
        
        // Disable printing
        window.addEventListener('beforeprint', function(e) {
            recordCheatingAttempt('print_attempt');
            e.preventDefault();
            return false;
        });
        
       function obfuscateQuestions() {
    // Only define once to avoid "cannot redefine" error
    try {
        if (!Object.getOwnPropertyDescriptor(window, 'questions')?.get) {
            Object.defineProperty(window, 'questions', {
                get: function() {
                    recordCheatingAttempt('questions_access');
                    return [];
                },
                configurable: true
            });
        }
    } catch (err) {
        console.warn('Could not obfuscate questions:', err);
    }
}
        
        // Initialize quiz timing
        function initializeQuizTiming() {
            quizStartTime = new Date();
            questionStartTime = new Date();
        }

        // Track question timing
        function trackQuestionTime() {
            if (questionStartTime) {
                const timeSpent = Math.floor((new Date() - questionStartTime) / 1000);
                questionTimes[currentQuestionIndex] = timeSpent;
            }
            questionStartTime = new Date(); // Reset for next question
        }

        // Fetch user session info and start quiz immediately
        async function fetchSessionInfo() {
            try {
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/session-info', {
                    credentials: 'include'
                });

                if (response.ok) {
                    const data = await response.json();
                    username = data.username;
                    email = data.email;
                    console.log("User:", username, "Email:", email);
                    return true;
                } else {
                    console.error('Failed to fetch session info');
                    alert('Please login to take the assessment');
                    window.location.href = '/login.html';
                    return false;
                }
            } catch (error) {
                console.error('Error fetching session info:', error);
                alert('Error connecting to server. Please try again.');
                return false;
            }
        }

        async function initializeQuiz() {
            try {
                // Initialize anti-cheating first
                initializeAntiCheating();
                
                const sessionValid = await fetchSessionInfo();
                if (!sessionValid) return;
                
                // NEW: Load questions from API
                const questionsLoaded = await loadQuestions();
                if (!questionsLoaded) return;
                
                currentUser = { username, email };
                
                // Initialize timing
                initializeQuizTiming();
                isQuizActive = true; // Enable anti-cheating monitoring
                
                // Hide loading screen and show quiz
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('quizContainer').style.display = 'block';
                
                // Obfuscate questions
                obfuscateQuestions();
                
                renderCurrentQuestion();
                updateProgress();
                
                // Full screen request (optional)
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen request failed:', err);
                    });
                }
            } catch (error) {
                console.error('Error initializing quiz:', error);
                alert('Error starting quiz. Please try again.');
            }
        }

        function renderCurrentQuestion() {
    const container = document.getElementById('questionContainer');
    const question = questions[currentQuestionIndex];
    
    console.log('Rendering question:', currentQuestionIndex + 1, question);
    
    container.innerHTML = '';

    const questionDiv = document.createElement('div');
    questionDiv.className = 'question-card';

    let optionsHtml = '';
    
    if (question.type === 'multiple_choice' && question.options && question.options.length > 0) {
        optionsHtml = question.options.map((option, optIndex) => {
            const safeOption = String(option).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            return `
                <div class="option" onclick="selectOption(${currentQuestionIndex}, '${safeOption}', 'radio')">
                    <input type="radio" name="q${currentQuestionIndex}" value="${safeOption}" id="q${currentQuestionIndex}_${optIndex}">
                    <label for="q${currentQuestionIndex}_${optIndex}">${option}</label>
                </div>
            `;
        }).join('');
    } else if (question.type === 'multiple_select' && question.options && question.options.length > 0) {
        optionsHtml = question.options.map((option, optIndex) => {
            const safeOption = String(option).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            return `
                <div class="option" onclick="selectOption(${currentQuestionIndex}, '${safeOption}', 'checkbox')">
                    <input type="checkbox" name="q${currentQuestionIndex}" value="${safeOption}" id="q${currentQuestionIndex}_${optIndex}">
                    <label for="q${currentQuestionIndex}_${optIndex}">${option}</label>
                </div>
            `;
        }).join('');
    } else if (['numeric', 'interval_input', 'numeric_input', 'coordinate_input', 'equation_input', 'text_input'].includes(question.type)) {
        let placeholder, formatExample, formatHint;
        
        if (question.type === 'coordinate_input') {
            placeholder = "e.g., (3, 4) or (3,4) or any format";
            formatExample = "(x, y) - any format accepted";
            formatHint = "‚úì All formats accepted: (3,4), (3, 4), x=3,y=4";
        } else if (question.type === 'equation_input') {
            placeholder = "e.g., y = log(x) + 2 or any equation";
            formatExample = "equation with = - any format accepted";
            formatHint = "‚úì All formats accepted: y=log(x)+2, y = log(x) + 2, f(x)=x^2";
        } else if (question.type === 'interval_input') {
            placeholder = "e.g., (0, inf), [1, ‚àû), (-infinity, 5], or any interval";
            formatExample = "[a,b] or (a,b) with any infinity format";
            formatHint = "‚úì All infinity formats: inf, infinity, Inf, ‚àû, -inf, -‚àû";
        } else if (question.type === 'numeric' || question.type === 'numeric_input') {
            placeholder = "e.g., 42, -3.14, inf, -infinity, ‚àû, or any number";
            formatExample = "number or infinity - any format accepted";
            formatHint = "‚úì All formats accepted: 42, -3.14, 0.5, inf, -infinity, ‚àû, +‚àû";
        } else {
            placeholder = "Enter your answer - any format accepted";
            formatExample = "text - any format accepted";
            formatHint = "‚úì All text formats accepted";
        }
        
        optionsHtml = `
            <div style="background: #f0f8ff; border: 2px dashed #667eea; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <span style="font-size: 18px;">üìù</span>
                    <strong style="color: #667eea;">Format Required: ${formatExample}</strong>
                </div>
                <div style="font-size: 13px; color: #666; line-height: 1.5;">
                    ${formatHint}
                </div>
            </div>
            <input type="text" 
                   class="numeric-input" 
                   placeholder="${placeholder}" 
                   onchange="handleNumericInputWithValidation(${currentQuestionIndex}, this.value)"
                   oninput="handleNumericInput(${currentQuestionIndex}, this.value)"
                   autocomplete="off"
                   spellcheck="false"
                   style="width: 100%; max-width: 300px; font-size: 16px; font-family: 'Courier New', monospace;">
            <div id="feedback-${currentQuestionIndex}" style="margin-top: 10px; min-height: 24px;"></div>
        `;
    } else {
        console.warn('Unknown question type or missing options:', question.type, question);
        optionsHtml = `
            <div style="color: #dc3545; padding: 15px; background: #f8d7da; border-radius: 8px;">
                <strong>Error:</strong> Unable to display question options. Please contact administrator.
            </div>
        `;
    }

    const difficultyColor = {
        'easy': '#28a745',
        'medium': '#ffc107', 
        'hard': '#dc3545'
    };
    
    const difficulty = question.difficulty || 'medium';
    const difficultyText = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);

// Use question text exactly as stored in database
let processedQuestionText = question.question_text || 'Question text not available';

console.log('üîç Original question:', processedQuestionText);

// ============================================
// COMPREHENSIVE LATEX PROCESSOR
// Handles all possible mathematical notation
// ============================================

// Step 1: Normalize special characters and unicode
processedQuestionText = processedQuestionText
    // Standard functions: f(x), g(t), h(a), but NOT if already wrapped
    .replace(/\b([fghlmnpqrFGHLMNPQR])\s*\(([^)]+)\)(?![^$]*\$)/g, '$$$$1($2)$$')
    // Numerical functions: 1(x), 2(a) - for piecewise notation (SPECIAL CASE)
    .replace(/\b([0-9]+)\s*\(([a-z])\)(?![^$]*\$)/g, '$$$1($2)$$');

// ADD THIS NEW STEP FOR THE SPECIFIC CASE IN THE IMAGE:
// Step 10.5: Fix the specific case from the image - 1(x) with dollar signs inside
processedQuestionText = processedQuestionText
    // Handle cases like: 1(x) = \frac{\$1^2\$-4}{x-2}
    .replace(/(\b[0-9]+\([a-z]\)\s*=\s*)\\frac{\\\$([^\\$]+)\\\$-\s*([^}]+)}/g, '$$$1\\frac{$2-$3}$$')
    // Handle the specific pattern from the image
    .replace(/\\frac{\\\$([^\\$]+)\\\$-\s*([^}]+)}/g, '$$\\frac{$1-$2}$$')
    // Clean up escaped dollar signs
    .replace(/\\\$/g, '$');
processedQuestionText = processedQuestionText
    .replace(/‚â†/g, '\\neq')
    .replace(/‚â§/g, '\\leq')
    .replace(/‚â•/g, '\\geq')
    .replace(/‚Üí/g, '\\to')
    .replace(/‚Üê/g, '\\leftarrow')
    .replace(/‚àû/g, '\\infty')
    .replace(/¬±/g, '\\pm')
    .replace(/√ó/g, '\\times')
    .replace(/√∑/g, '\\div')
    .replace(/‚àö/g, '\\sqrt')
    .replace(/œÄ/g, '\\pi')
    .replace(/Œ∏/g, '\\theta')
    .replace(/‚àë/g, '\\sum')
    .replace(/‚à´/g, '\\int')
    .replace(/‚àÇ/g, '\\partial')
    .replace(/‚àÜ/g, '\\Delta')
    .replace(/Œ±/g, '\\alpha')
    .replace(/Œ≤/g, '\\beta')
    .replace(/Œ≥/g, '\\gamma');

// Step 2: Protect already wrapped math expressions
const protectedExpressions = [];
let protectCounter = 0;

processedQuestionText = processedQuestionText
    .replace(/\$\$([^$]+)\$\$/g, (match) => {
        const placeholder = `__PROTECTED_${protectCounter}__`;
        protectedExpressions.push({ placeholder, content: match });
        protectCounter++;
        return placeholder;
    })
    .replace(/\$([^$]+)\$/g, (match) => {
        const placeholder = `__PROTECTED_${protectCounter}__`;
        protectedExpressions.push({ placeholder, content: match });
        protectCounter++;
        return placeholder;
    })
    .replace(/\\\(([^)]+)\\\)/g, (match) => {
        const placeholder = `__PROTECTED_${protectCounter}__`;
        protectedExpressions.push({ placeholder, content: match });
        protectCounter++;
        return placeholder;
    });

// Step 3: Process LIMITS (must come first, before function wrapping)
processedQuestionText = processedQuestionText
    // lim(x‚Üí0), lim(x->0), lim as x‚Üí0
    .replace(/lim\s*\(\s*([a-z])\s*‚Üí\s*([^)]+)\)/gi, '$\\lim_{$1 \\to $2}$')
    .replace(/lim\s*\(\s*([a-z])\s*->\s*([^)]+)\)/gi, '$\\lim_{$1 \\to $2}$')
    .replace(/lim\s+as\s+([a-z])\s*‚Üí\s*([^\s,;.]+)/gi, '$\\lim_{$1 \\to $2}$')
    .replace(/lim\s+as\s+([a-z])\s*->\s*([^\s,;.]+)/gi, '$\\lim_{$1 \\to $2}$')
    // lim_{x‚Üí0}, lim x‚Üí0
    .replace(/lim_\{([a-z])\s*‚Üí\s*([^}]+)\}/gi, '$\\lim_{$1 \\to $2}$')
    .replace(/lim_\{([a-z])\s*->\s*([^}]+)\}/gi, '$\\lim_{$1 \\to $2}$')
    .replace(/lim\s+([a-z])\s*‚Üí\s*([^\s,;.]+)/gi, '$\\lim_{$1 \\to $2}$');

// Step 4: Process FRACTIONS (comprehensive patterns)
processedQuestionText = processedQuestionText
    // Complex fractions: (x-1)/(x¬≤-1), (a+b)/(c+d)
    .replace(/\(([^)]+)\)\s*\/\s*\(([^)]+)\)/g, '$\\frac{$1}{$2}$')
    // Simple fractions with parentheses: (x-1)/x¬≤, a/(x+1)
    .replace(/\(([^)]+)\)\s*\/\s*([a-z][a-z0-9¬≤¬≥]*(?:\^[0-9]+)?)/gi, '$\\frac{$1}{$2}$')
    .replace(/([a-z0-9]+)\s*\/\s*\(([^)]+)\)/gi, '$\\frac{$1}{$2}$')
    // Number/variable fractions: 1/x, 1/x¬≤, x/y
    .replace(/([0-9]+)\s*\/\s*([a-z](?:\^[0-9]+|¬≤|¬≥)?)/gi, '$\\frac{$1}{$2}$')
    .replace(/([a-z])\s*\/\s*([a-z](?:\^[0-9]+|¬≤|¬≥)?)/gi, '$\\frac{$1}{$2}$')
    // Handle malformed fractions like /1¬≤, /x¬≤
    .replace(/\/\s*([0-9]+)¬≤/g, '/x^{$1}') // Fix /1¬≤ to /x¬≤
    .replace(/\/\s*([a-z])¬≤/gi, '/$1^2')
    .replace(/\/\s*([a-z])\^([0-9]+)/gi, '/$1^{$2}');

// Step 5: Process EXPONENTS
processedQuestionText = processedQuestionText
    // Exponents with parentheses: e^(-x), x^(1/x), 2^(n+1)
    .replace(/([a-z0-9])\^\(([^)]+)\)/gi, '$$$$1^{$2}$$')
    // Unicode superscripts: x¬≤, x¬≥
    .replace(/([a-z0-9])¬≤/gi, '$$$$1^2$$')
    .replace(/([a-z0-9])¬≥/gi, '$$$$1^3$$')
    // Caret notation: x^2, e^x, 10^n
    .replace(/([a-z0-9])\^([0-9]+)/gi, '$$$$1^{$2}$$')
    .replace(/([a-z0-9])\^([a-z])/gi, '$$$$1^{$2}$$')
    // Negative exponents: x^-1, e^-x
    .replace(/([a-z0-9])\^-([a-z0-9]+)/gi, '$$$$1^{-$2}$$');

// Step 6: Process DERIVATIVES
processedQuestionText = processedQuestionText
    // Function derivatives: f'(x), g'(1), h''(x)
    .replace(/\b([fghlmnpqrFGHLMNPQR])''+\s*\(([^)]+)\)/g, (match, func, arg) => {
        const primes = match.match(/'+/)[0];
        return `$$${func}${primes}(${arg})$$`;
    })
    .replace(/\b([fghlmnpqrFGHLMNPQR])'\s*\(([^)]+)\)/g, "$$$$1'($2)$$")
    // Composition derivatives: (f‚àòg)'(x), (fog)'(x)
    .replace(/\(([fgh])\s*‚àò\s*([fgh])\)'\s*\(([^)]+)\)/g, "$$($$1 \\circ $$2)'($3)$$")
    .replace(/\(([fgh])o([fgh])\)'\s*\(([^)]+)\)/g, "$$($$1 \\circ $$2)'($3)$$");

// Step 7: Process TRIG & LOG FUNCTIONS
processedQuestionText = processedQuestionText
    .replace(/\b(sin|cos|tan|sec|csc|cot|arcsin|arccos|arctan|arcsec|arccsc|arccot|sinh|cosh|tanh|sech|csch|coth)\s*\(([^)]+)\)/gi, '$$\\$1($2)$$')
    .replace(/\b(ln|log|exp)\s*\(([^)]+)\)/gi, '$$\\$1($2)$$');

// Step 8: Process SQUARE ROOTS
processedQuestionText = processedQuestionText
    .replace(/sqrt\s*\(([^)]+)\)/gi, '$$\\sqrt{$1}$$')
    .replace(/‚àö\s*\(([^)]+)\)/g, '$$\\sqrt{$1}$$')
    .replace(/‚àö\s*([0-9]+)/g, '$$\\sqrt{$1}$$');

// Step 9: Process ABSOLUTE VALUES
processedQuestionText = processedQuestionText
    .replace(/\|([^|]+)\|/g, '$$|$1|$$');

// Step 10: Process REGULAR FUNCTIONS
processedQuestionText = processedQuestionText
    // Standard functions: f(x), g(t), h(a), but NOT if already wrapped
    .replace(/\b([fghlmnpqrFGHLMNPQR])\s*\(([^)]+)\)(?![^$]*\$)/g, '$$$$1($2)$$')
    // Numerical functions: 1(x), 2(a) - for piecewise notation
    .replace(/\b([0-9]+)\s*\(([a-z])\)(?![^$]*\$)/g, '$$$1($2)$$');

// Step 11: Process PIECEWISE FUNCTIONS & CASES
processedQuestionText = processedQuestionText
    // Piecewise with { }: { x¬≤ if x > 0; x if x ‚â§ 0 }
    .replace(/\{([^}]*\bif\b[^}]*)\}/g, (match, inner) => {
        // Check if it's a complex piecewise
        if (inner.includes(';') || inner.includes(',')) {
            const cases = inner.split(/[;,]/).map(c => c.trim());
            const formatted = cases.map(c => {
                const parts = c.split(/\s+if\s+/i);
                if (parts.length === 2) {
                    return `${parts[0]} & \\text{if } ${parts[1]}`;
                }
                return c;
            }).join(' \\\\ ');
            return `$\\begin{cases} ${formatted} \\end{cases}$`;
        }
        return `$\\{${inner}\\}$`;
    });

// Step 12: Process INTERVALS
processedQuestionText = processedQuestionText
    // Interval notation: [0, 1], (-‚àû, ‚àû), (a, b]
    .replace(/\[([^,\]]+),\s*([^\]]+)\]/g, '$$[$1, $2]$$')
    .replace(/\(([^,)]+),\s*([^)]+)\)/g, '$$($$1, $$2)$$');

// Step 13: Process COMPARISON OPERATORS & EQUATIONS
processedQuestionText = processedQuestionText
    // Equations: x = 1, y ‚â† 0, a < b
    .replace(/\b([a-z])\s*(=|‚â†|<|>|‚â§|‚â•|\\neq|\\leq|\\geq)\s*(-?[0-9.]+)(?![^$]*\$)/g, '$$$$1 $2 $3$$')
    .replace(/\b([a-z])\s*(=|‚â†|<|>|‚â§|‚â•|\\neq|\\leq|\\geq)\s*([a-z])(?![^$]*\$)/g, '$$$$1 $2 $3$$');

// Step 14: Process STANDALONE VARIABLES IN CONTEXT
processedQuestionText = processedQuestionText
    // Variables in phrases: "at x = 1", "for x > 0"
    .replace(/\bat\s+([a-z])\s*=\s*(-?[0-9.]+)/gi, 'at $$$$1 = $2$$')
    .replace(/\bfor\s+([a-z])\s*([<>‚â§‚â•‚â†])\s*(-?[0-9.]+)/gi, 'for $$$$1 $2 $3$$')
    .replace(/\bwhen\s+([a-z])\s*=\s*(-?[0-9.]+)/gi, 'when $$$$1 = $2$$');

// Step 15: Clean up multiple/nested dollar signs
processedQuestionText = processedQuestionText
    // Remove nested dollars: $...$...$
    .replace(/\$+/g, '$')
    // Remove empty math: $$
    .replace(/\$\s*\$/g, '')
    // Remove space around dollars
    .replace(/\$\s+/g, '$')
    .replace(/\s+\$/g, '$')
    // Fix double dollars that got created
    .replace(/\$\$/g, '$');

// Step 16: Restore protected expressions
protectedExpressions.forEach(({ placeholder, content }) => {
    processedQuestionText = processedQuestionText.replace(placeholder, content);
});

// Final cleanup
processedQuestionText = processedQuestionText.trim();

console.log('‚úÖ Processed question:', processedQuestionText);

    questionDiv.innerHTML = `
        <div class="question-header">
            <div class="question-number">${currentQuestionIndex + 1}</div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="background: ${difficultyColor[difficulty]}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; text-transform: uppercase;">
                    ${difficultyText}
                </span>
            </div>
        </div>
        <div class="question-text" id="question-text-${currentQuestionIndex}">${processedQuestionText}</div>
        <div class="options">${optionsHtml}</div>
    `;

    container.appendChild(questionDiv);
    
    // Force MathJax rendering with error handling
    setTimeout(() => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([questionDiv]).then(() => {
                console.log('‚úÖ MathJax rendered for question', currentQuestionIndex + 1);
            }).catch(err => {
                console.error('‚ùå MathJax error:', err);
            });
        }
    }, 200);
    
    // Restore previous answer if exists
    restoreAnswer();
    updateAnswerStatus();
}

        function restoreAnswer() {
            const question = questions[currentQuestionIndex];
            const savedAnswer = userAnswers[currentQuestionIndex];
            
            if (!savedAnswer) return;

            if (question.type === 'multiple_choice') {
                const option = document.querySelector(`input[value="${savedAnswer}"]`);
                if (option) {
                    option.checked = true;
                    option.closest('.option').classList.add('selected');
                }
            } else if (question.type === 'multiple_select' && Array.isArray(savedAnswer)) {
                savedAnswer.forEach(answer => {
                    const option = document.querySelector(`input[value="${answer}"]`);
                    if (option) {
                        option.checked = true;
                        option.closest('.option').classList.add('selected');
                    }
                });
            } else if (question.type === 'numeric' || question.type === 'interval_input' || question.type === 'numeric_input' || question.type === 'coordinate_input' || question.type === 'equation_input' || question.type === 'text_input') {
                const input = document.querySelector('.numeric-input');
                if (input) {
                    input.value = savedAnswer;
                }
            }
        }

        function updateProgress() {
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
            document.getElementById('questionStatus').textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
            
            // Update navigation buttons
            document.getElementById('prevBtn').disabled = currentQuestionIndex === 0;
            
            const nextBtn = document.getElementById('nextBtn');
            if (currentQuestionIndex === questions.length - 1) {
                nextBtn.textContent = 'Finish';
                nextBtn.onclick = () => {
                    document.getElementById('quizContainer').scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'end' 
                    });
                };
            } else {
                nextBtn.textContent = 'Next';
                nextBtn.onclick = nextQuestion;
            }
        }

        function updateAnswerStatus() {
            const statusSpan = document.getElementById('answeredStatus');
            const hasAnswer = userAnswers[currentQuestionIndex] !== undefined;
            
            if (hasAnswer) {
                statusSpan.textContent = 'Answered';
                statusSpan.className = 'status-answered';
            } else {
                statusSpan.textContent = 'Unanswered';
                statusSpan.className = 'status-unanswered';
            }
        }

        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                trackQuestionTime();
                currentQuestionIndex++;
                renderCurrentQuestion();
                updateProgress();
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                trackQuestionTime();
                currentQuestionIndex--;
                renderCurrentQuestion();
                updateProgress();
            }
        }

        function selectOption(questionIndex, value, type) {
            if (type === 'radio') {
                userAnswers[questionIndex] = value.trim();
                const options = document.querySelectorAll(`input[name="q${questionIndex}"]`);
                options.forEach(opt => opt.closest('.option').classList.remove('selected'));
                event.target.closest('.option').classList.add('selected');
            } else if (type === 'checkbox') {
                if (!userAnswers[questionIndex]) userAnswers[questionIndex] = [];
                
                const checkbox = event.target.closest('.option').querySelector('input');
                if (checkbox.checked) {
                    if (!userAnswers[questionIndex].includes(value.trim())) {
                        userAnswers[questionIndex].push(value.trim());
                    }
                    event.target.closest('.option').classList.add('selected');
                } else {
                    userAnswers[questionIndex] = userAnswers[questionIndex].filter(ans => ans !== value.trim());
                    event.target.closest('.option').classList.remove('selected');
                    
                    if (userAnswers[questionIndex].length === 0) {
                        delete userAnswers[questionIndex];
                    }
                }
            }
            updateAnswerStatus();
        }

        function handleNumericInput(questionIndex, value) {
            const question = questions[questionIndex];
            const trimmedValue = value.trim();
            
            if (trimmedValue) {
                userAnswers[questionIndex] = trimmedValue; // Stores EXACTLY what user typed
            } else {
                delete userAnswers[questionIndex];
            }
            
            updateAnswerStatus();
        }

        function validateAnswerFormat(questionIndex, userAnswer) {
            const question = questions[currentQuestionIndex];
            let feedback = '';
            let isValidFormat = true;
            let suggestion = '';
            
            if (question.type === 'coordinate_input') {
                // Remove strict validation, just provide guidance
                feedback = '‚úì Any format accepted';
                suggestion = 'Examples: (3, 4), (2.5, -1.3), (x, y)';
                isValidFormat = true;
            } else if (question.type === 'equation_input') {
                feedback = '‚úì Any format accepted';
                suggestion = 'Examples: y = log(x) + 2, f(x)=x^2, equation with = sign';
                isValidFormat = true;
            } else if (question.type === 'numeric' || question.type === 'numeric_input') {
                feedback = '‚úì Any number format accepted';
                suggestion = 'Examples: 42, -3.14, 0.5, inf, -infinity, ‚àû';
                isValidFormat = true;
            } else if (question.type === 'interval_input') {
                feedback = '‚úì Any interval format accepted';
                suggestion = 'Examples: (0, inf), [1, 10], (-‚àû, 5], (a, b)';
                isValidFormat = true;
            } else {
                feedback = '‚úì Any text format accepted';
                suggestion = '';
                isValidFormat = true;
            }
            
            return { isValidFormat, feedback, suggestion };
        }

        function showValidationFeedback(questionIndex, feedback, suggestion) {
            const feedbackDiv = document.getElementById(`feedback-${questionIndex}`);
            if (!feedbackDiv) return;
            
            if (!feedback) {
                feedbackDiv.innerHTML = '';
                return;
            }
            
            const isValid = feedback.includes('‚úì');
            feedbackDiv.style.cssText = `
                background: ${isValid ? '#d4edda' : '#fff3cd'};
                border: 1px solid ${isValid ? '#c3e6cb' : '#ffeaa7'};
                border-radius: 6px;
                padding: 10px;
                margin-top: 10px;
                font-size: 14px;
                line-height: 1.5;
            `;
            
            feedbackDiv.innerHTML = `
                <div style="color: ${isValid ? '#155724' : '#856404'}; font-weight: 600; margin-bottom: 4px;">
                    ${feedback}
                </div>
                ${suggestion ? `<div style="color: #666; font-size: 13px;">${suggestion}</div>` : ''}
            `;
        }

        function handleNumericInputWithValidation(questionIndex, value) {
            handleNumericInput(questionIndex, value);
            
            if (value.trim()) {
                const validation = validateAnswerFormat(questionIndex, value.trim());
                showValidationFeedback(questionIndex, validation.feedback, validation.suggestion);
            } else {
                showValidationFeedback(questionIndex, '', '');
            }
        }

        function getQuestionDifficulty(questionNumber) {
            if (questionNumber <= 15) return 'easy';
            if (questionNumber <= 30) return 'medium';
            return 'hard';
        }

        async function submitQuiz() {
            const confirmSubmit = confirm(`Ready to Submit?\n\nPlease make sure you have reviewed all your answers before submitting.\nOnce submitted, you won't be able to make changes.\n\nAre you ready to submit your Limits, Continuity and Differentiation Quiz?`);
            
            if (!confirmSubmit) {
                return;
            }
        
            if (!username || !email) {
                alert("Error: User session data not found. Please log in.");
                return;
            }

            trackQuestionTime();
            isQuizActive = false;
            const quizEndTime = new Date();
            const totalTimeTaken = Math.floor((quizEndTime - quizStartTime) / 1000);

            let score = 0;
            let totalPossiblePoints = 0;
            const questionResults = [];
            const difficultyBreakdown = {
                easy: { attempted: 0, correct: 0, points: 0 },
                medium: { attempted: 0, correct: 0, points: 0 },
                hard: { attempted: 0, correct: 0, points: 0 }
            };
            
            // Enhanced answer comparison with flexible infinity support
            questions.forEach((question, index) => {
                const userAnswer = userAnswers[index];
                totalPossiblePoints += question.points;
                
                let isCorrect = false;
                
                if (userAnswer !== undefined && userAnswer !== null) {
                    const normalizedUser = answerNormalizer.normalizeAnswer(userAnswer, question.type);
                    const normalizedCorrect = answerNormalizer.normalizeAnswer(question.correct_answer, question.type);
                    
                    if (question.type === 'interval_input') {
                        // For intervals, compare normalized strings
                        isCorrect = normalizedUser === normalizedCorrect;
                        
                        // Check alternative answers
                        if (!isCorrect && question.alternative_answers && Array.isArray(question.alternative_answers)) {
                            isCorrect = question.alternative_answers.some(alt => {
                                const normalizedAlt = answerNormalizer.normalizeAnswer(alt, question.type);
                                return normalizedAlt === normalizedUser;
                            });
                        }
                    } else if (question.type === 'multiple_choice') {
                        isCorrect = normalizedUser === normalizedCorrect;
                    } else if (question.type === 'multiple_select') {
                        if (Array.isArray(userAnswer) && Array.isArray(question.correct_answer)) {
                            const normalizeArray = (arr) => arr.map(item => 
                                answerNormalizer.normalizeAnswer(item, question.type)).sort();
                            const userNorm = normalizeArray(userAnswer);
                            const correctNorm = normalizeArray(question.correct_answer);
                            isCorrect = userNorm.length === correctNorm.length &&
                                    userNorm.every((ans, idx) => ans === correctNorm[idx]);
                        }
                    } else if (question.type === 'numeric' || question.type === 'numeric_input') {
                        // Handle numeric comparisons with tolerance for floating point
                        const userNum = answerNormalizer.normalizeNumeric(userAnswer);
                        const correctNum = answerNormalizer.normalizeNumeric(question.correct_answer);
                        
                        if (userNum === correctNum) {
                            // Exact match (including Infinity/-Infinity)
                            isCorrect = true;
                        } else if (isFinite(userNum) && isFinite(correctNum)) {
                            // Both are finite numbers - use tolerance
                            const tolerance = Math.max(Math.abs(correctNum) * 0.01, 0.01);
                            isCorrect = Math.abs(userNum - correctNum) <= tolerance;
                        } else {
                            // One is infinite, one is not
                            isCorrect = false;
                        }
                        
                        // Check alternative numeric answers
                        if (!isCorrect && question.alternative_answers && Array.isArray(question.alternative_answers)) {
                            isCorrect = question.alternative_answers.some(alt => {
                                const altNum = answerNormalizer.normalizeNumeric(alt);
                                if (userNum === altNum) return true;
                                if (isFinite(userNum) && isFinite(altNum)) {
                                    const tolerance = Math.max(Math.abs(altNum) * 0.01, 0.01);
                                    return Math.abs(userNum - altNum) <= tolerance;
                                }
                                return false;
                            });
                        }
                    } else if (question.type === 'coordinate_input') {
                        isCorrect = normalizedUser === normalizedCorrect;
                    } else if (question.type === 'equation_input') {
                        isCorrect = normalizedUser === normalizedCorrect;
                        
                        if (!isCorrect && question.alternative_answers && Array.isArray(question.alternative_answers)) {
                            isCorrect = question.alternative_answers.some(alt => {
                                const normalizedAlt = answerNormalizer.normalizeAnswer(alt, question.type);
                                return normalizedAlt === normalizedUser;
                            });
                        }
                    } else {
                        // For text input and other types
                        isCorrect = normalizedUser === normalizedCorrect;
                    }
                }
                
                if (isCorrect) {
                    score += question.points;
                }
                
                difficultyBreakdown[question.difficulty].attempted++;
                if (isCorrect) {
                    difficultyBreakdown[question.difficulty].correct++;
                    difficultyBreakdown[question.difficulty].points += question.points;
                }
                
                questionResults.push({
                    questionId: question._id,
                    questionNumber: question.question_number,
                    questionText: question.question_text,
                    difficulty: question.difficulty,
                    points: question.points,
                    userAnswer: userAnswer ? userAnswer.toString() : 'No answer provided',
                    correctAnswer: question.correct_answer.toString(),
                    explanation: question.explanation || '',
                    isCorrect: isCorrect,
                    timeTaken: questionTimes[index] || 0
                });
            });

            const quizData = {
                topic: 'Limit_Concepts',
                quizType: 'practice',
                score: score,
                maxPossibleScore: totalPossiblePoints,
                totalQuestions: questions.length,
                correctAnswers: questionResults.filter(q => q.isCorrect).length,
                percentage: Math.round((score / totalPossiblePoints) * 100),
                difficultyBreakdown: difficultyBreakdown,
                questionResults: questionResults,
                startTime: quizStartTime,
                endTime: quizEndTime,
                totalTimeTaken: totalTimeTaken,
                isCompleted: true,
                adaptiveData: {
                    startingDifficulty: 'easy',
                    finalDifficulty: questions[questions.length - 1]?.difficulty || 'easy',
                    difficultyProgression: questionResults.map((q, index) => ({
                        questionNumber: q.questionNumber,
                        difficulty: q.difficulty,
                        wasCorrect: q.isCorrect
                    }))
                }
            };

            try {
                document.getElementById('submitText').style.display = 'none';
                document.getElementById('submitLoading').style.display = 'inline-block';
                document.getElementById('submitBtn').disabled = true;

                console.log('Submitting quiz data:', {
                    email: email,
                    username: username,
                    quizData: quizData
                });
                
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/iitmmath_scores', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        email: email,
                        username: username,
                        quizData: quizData
                    })
                });

                if (response.ok) {
                    console.log('Quiz submitted successfully');
                    displayDetailedResults(quizData);
                } else {
                    const errorText = await response.text();
                    console.error('Failed to submit quiz:', errorText);
                    alert('Failed to submit quiz. Please try again.');
                    
                    document.getElementById('submitText').style.display = 'inline';
                    document.getElementById('submitLoading').style.display = 'none';
                    document.getElementById('submitBtn').disabled = false;
                    return;
                }
            } catch (error) {
                console.error('Error submitting quiz:', error);
                alert('Error submitting quiz. Please check your connection and try again.');
                document.getElementById('submitText').style.display = 'inline';
                document.getElementById('submitLoading').style.display = 'none';
                document.getElementById('submitBtn').disabled = false;
                return;
            }
        }

        function displayDetailedResults(quizData) {
            document.getElementById('quizContainer').style.display = 'none';
            
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.style.display = 'block';
            
            const scoreDisplay = document.querySelector('.score-display');
            scoreDisplay.innerHTML = `
                <h2>${quizData.score}/${quizData.maxPossibleScore} Points (${quizData.percentage}%)</h2>
                <p>Quiz Completed Successfully!</p>
                <div style="margin-top: 20px; display: flex; justify-content: space-around; text-align: center;">
                    <div>
                        <strong>Easy Questions</strong><br>
                        ${quizData.difficultyBreakdown.easy.correct}/${quizData.difficultyBreakdown.easy.attempted}
                    </div>
                    <div>
                        <strong>Medium Questions</strong><br>
                        ${quizData.difficultyBreakdown.medium.correct}/${quizData.difficultyBreakdown.medium.attempted}
                    </div>
                    <div>
                        <strong>Hard Questions</strong><br>
                        ${quizData.difficultyBreakdown.hard.correct}/${quizData.difficultyBreakdown.hard.attempted}
                    </div>
                </div>
                <p style="margin-top: 15px; font-size: 0.9em;">
                    Time Taken: ${Math.floor(quizData.totalTimeTaken / 60)}m ${quizData.totalTimeTaken % 60}s
                </p>
            `;
            
            const reviewDiv = document.createElement('div');
            reviewDiv.style.cssText = `
                margin-top: 30px;
                text-align: left;
                background: white;
                border-radius: 10px;
                padding: 20px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            `;
            
            reviewDiv.innerHTML = `
                <h3 style="text-align: center; margin-bottom: 25px; color: #333;">Question Review</h3>
                ${quizData.questionResults.map(result => `
                    <div style="border: 2px solid ${result.isCorrect ? '#28a745' : '#dc3545'}; 
                                border-radius: 8px; 
                                padding: 15px; 
                                margin-bottom: 15px; 
                                background: ${result.isCorrect ? '#f8fff9' : '#fff8f8'};">
                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                            <span style="background: ${result.isCorrect ? '#28a745' : '#dc3545'}; 
                                        color: white; 
                                        padding: 4px 8px; 
                                        border-radius: 50%; 
                                        margin-right: 10px; 
                                        font-weight: bold;">
                                ${result.questionNumber}
                            </span>
                            <span style="font-weight: bold; color: ${result.isCorrect ? '#28a745' : '#dc3545'};">
                                ${result.isCorrect ? '‚úì Correct' : '‚úó Incorrect'}
                            </span>
                        </div>
                        <div style="margin-bottom: 10px; line-height: 1.4;">
                            <strong>Question:</strong> ${result.questionText}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Your Answer:</strong> 
                            <span style="color: ${result.isCorrect ? '#28a745' : '#dc3545'}; font-weight: bold;">
                                ${result.userAnswer || 'No answer provided'}
                            </span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Correct Answer:</strong> 
                            <span style="color: #28a745; font-weight: bold;">
                                ${result.correctAnswer}
                            </span>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Explanation:</strong> 
                            <span style="color: #28a745; font-weight: bold;">
                                ${result.explanation}
                            </span>
                        </div>
                        <div style="font-size: 0.9em; color: #666;">
                            Time taken: ${result.timeTaken}s
                        </div>
                    </div>
                `).join('')}
            `;
            
            resultsContainer.appendChild(reviewDiv);

            // Process MathJax for results page with delay
            setTimeout(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise([reviewDiv]).then(() => {
                        console.log('‚úÖ MathJax rendered in results');
                    }).catch(err => {
                        console.error('‚ùå MathJax error in results:', err);
                    });
                }
            }, 800);
            }
        

      

        function getDifficultyColor(difficulty) {
            switch(difficulty) {
                case 'easy': return '#28a745';
                case 'medium': return '#ffc107';
                case 'hard': return '#dc3545';
                default: return '#6c757d';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initializeQuiz();
        });

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeQuiz);
        } else {
            initializeQuiz();
        }

        async function loadQuestions() {
            try {
                if (!email) {
                    alert('Please login to take the assessment');
                    return false;
                }
                
                // Step 1: Get user's answered question IDs from their quiz history
                const answeredQuestionIds = await getAnsweredQuestionIds();
                console.log('üìù Already answered question IDs:', answeredQuestionIds);
                
                // Step 2: Fetch ALL questions for this topic
                const response = await fetch(`https://sanghamitra-learnworld.vercel.app/api/iitm-math-questions/Limit%20Concepts?email=${encodeURIComponent(email)}&count=1000`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                let allQuestions = data.questions || data;
                
                if (!allQuestions || allQuestions.length === 0) {
                    throw new Error('No questions found in database');
                }
                
                console.log('üìö Total questions in database:', allQuestions.length);
                console.log('‚úÖ Already answered:', answeredQuestionIds.length);
                
                // Step 3: Filter out already answered questions (FRONTEND FILTERING)
                const unansweredQuestions = allQuestions.filter(q => {
                    const questionId = q._id || q.id || q.question_number;
                    return !answeredQuestionIds.includes(questionId?.toString());
                });
                
                console.log('üÜï Unanswered questions available:', unansweredQuestions.length);
                
                // Step 4: Handle case where all questions are completed
                if (unansweredQuestions.length === 0) {
                    const resetConfirm = confirm(
                        `üéâ Congratulations! You have completed all ${allQuestions.length} questions!\n\n` +
                        `Questions completed: ${answeredQuestionIds.length}\n` +
                        `Total questions in pool: ${allQuestions.length}\n\n` +
                        `Would you like to reset your progress and start over?`
                    );
                    
                    if (resetConfirm) {
                        const resetSuccess = await resetUserProgress();
                        if (resetSuccess) {
                            return loadQuestions(); // Retry after reset
                        } else {
                            alert('Failed to reset progress. Please try again or contact support.');
                            window.location.href = 'iitm_math.html';
                            return false;
                        }
                    } else {
                        alert('No new questions available. Returning to home page.');
                        window.location.href = 'iitm_math.html';
                        return false;
                    }
                }
                
                // Step 5: Select random subset (e.g., 30 questions) from unanswered pool
                const questionsToShow = Math.min(30, unansweredQuestions.length);
                questions = shuffleArray(unansweredQuestions).slice(0, questionsToShow);
                
                console.log(`‚ú® Loaded ${questions.length} NEW (never-seen) questions`);
                
                // Step 6: Show progress to user
                const progressInfo = document.createElement('div');
                progressInfo.style.cssText = `
                    background: #e3f2fd;
                    padding: 10px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    text-align: center;
                    color: #1976d2;
                    font-size: 14px;
                `;
                progressInfo.innerHTML = `
                    üìä Your Progress: ${answeredQuestionIds.length} completed | 
                    ${unansweredQuestions.length} remaining | 
                    ${allQuestions.length} total questions
                `;
                document.getElementById('quizContainer').prepend(progressInfo);
                
                return true;
            } catch (error) {
                console.error('Error loading questions:', error);
                alert('Failed to load quiz questions. Please refresh and try again.');
                return false;
            }
        }
        
        // NEW FUNCTION: Get all question IDs user has already answered
        async function getAnsweredQuestionIds() {
            try {
                const response = await fetch(`https://sanghamitra-learnworld.vercel.app/api/iitmmath_scores?email=${encodeURIComponent(email)}&topic=Limit_Concepts`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    console.log('No previous quiz history found');
                    return [];
                }
                
                const scores = await response.json();
                const answeredIds = new Set();
                
                // Extract all question IDs from quiz history
                if (Array.isArray(scores)) {
                    scores.forEach(score => {
                        if (score.quizData && score.quizData.questionResults) {
                            score.quizData.questionResults.forEach(result => {
                                if (result.questionId) {
                                    answeredIds.add(result.questionId.toString());
                                }
                                // Also track by question number as fallback
                                if (result.questionNumber) {
                                    answeredIds.add(result.questionNumber.toString());
                                }
                            });
                        }
                    });
                }
                
                return Array.from(answeredIds);
            } catch (error) {
                console.error('Error fetching answered questions:', error);
                return []; // Return empty array if error (will show all questions)
            }
        }
        
        // NEW FUNCTION: Shuffle array for random question selection
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        async function resetUserProgress() {
            try {
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/reset-user-progress', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        email: email,
                        topic: 'Limit_Concepts'
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    console.log('Progress reset successfully:', data);
                    alert(`‚úÖ Progress reset successfully!\n\nYou can now retake all ${data.questionsAvailable || 'available'} questions.`);
                    return true;
                } else {
                    throw new Error(data.message || 'Failed to reset progress');
                }
            } catch (error) {
                console.error('Error resetting progress:', error);
                alert('‚ùå Failed to reset progress. Please try again or contact support.');
                return false;
            }
        }

        function goback() {
            userAnswers = {};
            questionTimes = {};
            window.location.href = 'iitm_math.html';
        }
    </script>
</body>
</html>
