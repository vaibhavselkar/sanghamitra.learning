<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Quiz</title>
    <!-- Include Monaco Editor for code editing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs/loader.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
    
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .quiz-container { padding: 30px; }

        .question-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
        }

        .code-editor-container {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin: 20px 0;
            height: 400px;
        }

        .test-cases {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-family: monospace;
        }

        .test-passed {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .test-failed {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .btn:hover { transform: translateY(-2px); }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .score-display {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }

        .results-container { display: none; padding: 30px; }
        .loading { display: none; }
        
        .explanation-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .option-label {
            display: block;
            padding: 12px 15px;
            margin: 8px 0;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option-label:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .option-label.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .numerical-input {
            width: 200px;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            margin: 10px 0;
        }

        .numerical-input:focus {
            border-color: #667eea;
            outline: none;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Sorting Algorithms & Time Complexity Quiz</h1>
            <p>Test your knowledge of Quick Sort, Merge Sort, and algorithm time complexity</p>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="quiz-container" style="text-align: center; padding: 60px;">
            <div class="loading" style="width: 40px; height: 40px; margin: 0 auto 20px;"></div>
            <h3>Loading Quiz...</h3>
            <p>Preparing your test environment</p>
        </div>

        <!-- Quiz Container -->
        <div id="quizContainer" class="quiz-container" style="display: none;">
            <div class="progress-container mb-4">
                <div class="d-flex justify-content-between mb-2">
                    <span id="progressText">Question 1 of 20</span>
                    <span id="scoreText">Score: 0/20</span>
                </div>
                <div class="progress">
                    <div class="progress-bar" id="progressFill" style="width: 5%;"></div>
                </div>
            </div>
            
            <div id="questionContainer"></div>
            
            <div class="d-flex justify-content-between mt-4">
                <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()" disabled>‚Üê Previous</button>
                <div>
                    <button class="btn" id="nextBtn" onclick="nextQuestion()">Next ‚Üí</button>
                </div>
            </div>
            
            <div class="text-center mt-4">
                <button class="btn btn-success" onclick="submitQuiz()" id="submitBtn">
                    üìä Submit Quiz
                </button>
            </div>
        </div>

        <!-- Results -->
        <div id="resultsContainer" class="results-container">
            <div class="score-display">
                <h2 id="finalScore">0/20</h2>
                <h3 id="finalPercentage">0%</h3>
                <p>Quiz Completed!</p>
            </div>
            <div id="detailedResults"></div>
            <button class="btn" onclick="restartQuiz()">Take Quiz Again</button>
        </div>
    </div>

    <script>
        const questions = [
            // Original 10 questions
            {
                questionId: 1,
                title: "What is the worst-case time complexity of Quick Sort?",
                type: "mcq-single",
                options: ["O(n log n)", "O(n¬≤)", "O(log n)", "O(n)"],
                correctAnswer: "O(n¬≤)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Quick Sort has worst-case time complexity of O(n¬≤) when the pivot is always the smallest or largest element (already sorted or reverse sorted array)."
            },
            {
                questionId: 2,
                title: "How many total comparisons are needed in the worst case to sort an array of 8 elements using Bubble Sort?",
                type: "numerical",
                correctAnswer: 28,
                maxScore: 1,
                hasExplanations: true,
                explanation: "Bubble Sort requires n*(n-1)/2 comparisons in worst case. For n=8: 8*7/2 = 28 comparisons."
            },
            {
                questionId: 3,
                title: "Which sorting algorithm uses the 'divide and conquer' strategy?",
                type: "mcq-single",
                options: ["Bubble Sort", "Insertion Sort", "Selection Sort", "Merge Sort"],
                correctAnswer: "Merge Sort",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Merge Sort uses the divide and conquer strategy by recursively splitting the array into halves and then merging sorted halves."
            },
            {
                questionId: 4,
                title: "In Selection Sort, how many swaps are required to sort [5, 4, 3, 2, 1]?",
                type: "numerical",
                correctAnswer: 4,
                maxScore: 1,
                hasExplanations: true,
                explanation: "Selection Sort performs exactly n-1 swaps. For 5 elements, it requires 4 swaps regardless of the initial order."
            },
            {
                questionId: 5,
                title: "Which sorting algorithm maintains the relative order of equal elements?",
                type: "mcq-single",
                options: ["Quick Sort", "Selection Sort", "Stable Sort", "Heap Sort"],
                correctAnswer: "Stable Sort",
                maxScore: 1,
                hasExplanations: true,
                explanation: "A stable sorting algorithm maintains the relative order of records with equal keys. Merge Sort and Insertion Sort are examples of stable sorts."
            },
            {
                questionId: 6,
                title: "What is the best-case time complexity of Insertion Sort?",
                type: "mcq-single",
                options: ["O(n¬≤)", "O(n log n)", "O(n)", "O(log n)"],
                correctAnswer: "O(n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Insertion Sort has best-case time complexity O(n) when the array is already sorted, as it only needs to make n-1 comparisons."
            },
            {
                questionId: 7,
                title: "How many passes are needed in worst case for Bubble Sort on an array of 6 elements?",
                type: "numerical",
                correctAnswer: 5,
                maxScore: 1,
                hasExplanations: true,
                explanation: "Bubble Sort requires n-1 passes in worst case. For 6 elements, it needs 5 passes."
            },
            {
                questionId: 8,
                title: "Which sorting algorithm has the best worst-case time complexity?",
                type: "mcq-single",
                options: ["Bubble Sort", "Quick Sort", "Insertion Sort", "Merge Sort"],
                correctAnswer: "Merge Sort",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Merge Sort has O(n log n) worst-case time complexity, which is better than Bubble Sort (O(n¬≤)), Quick Sort (O(n¬≤) worst-case), and Insertion Sort (O(n¬≤))."
            },
            {
                questionId: 9,
                title: "In Merge Sort, what is the space complexity?",
                type: "mcq-single",
                options: ["O(1)", "O(log n)", "O(n)", "O(n¬≤)"],
                correctAnswer: "O(n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Merge Sort requires O(n) additional space for the temporary arrays used during merging."
            },
            {
                questionId: 10,
                title: "How many inversions are in the array [3, 1, 2]? (An inversion is a pair where i < j but arr[i] > arr[j])",
                type: "numerical",
                correctAnswer: 2,
                maxScore: 1,
                hasExplanations: true,
                explanation: "Inversions: (3,1) and (3,2). Total 2 inversions."
            },

            // New 10 time complexity questions
            {
                questionId: 11,
                title: "Nested Loop Time Complexity",
                type: "mcq-single",
                description: "Determine the time complexity of a nested loop where both loops run n times.",
                code: `for i = 1 to n:
    for j = 1 to n:
        print(i, j)`,
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(2‚Åø)"],
                correctAnswer: "O(n¬≤)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Both loops run n times, so total iterations = n √ó n = n¬≤. Therefore, time complexity is O(n¬≤)."
            },
            {
                questionId: 12,
                title: "Triangular Loop Time Complexity",
                type: "mcq-single",
                description: "Find the time complexity of a nested loop where the inner loop depends on the outer loop.",
                code: `for i = 1 to n:
    for j = 1 to i:
        print(i, j)`,
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(n¬≥)"],
                correctAnswer: "O(n¬≤)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Total iterations = 1 + 2 + 3 + ... + n = n(n+1)/2 ‚âà n¬≤/2. Therefore, time complexity is O(n¬≤)."
            },
            {
                questionId: 13,
                title: "Logarithmic Loop Time Complexity",
                type: "mcq-single",
                description: "If a loop runs as i = 1 to n and the inner loop runs j = 1 to log n, what is the total time complexity?",
                code: `for i = 1 to n:
    for j = 1 to log n:
        # Some constant time operation`,
                options: ["O(n)", "O(n log n)", "O(log n)", "O(n¬≤)"],
                correctAnswer: "O(n log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Outer loop runs n times, inner loop runs log n times. Total iterations = n √ó log n. Therefore, time complexity is O(n log n)."
            },
            {
                questionId: 14,
                title: "Binary Search Time Complexity",
                type: "mcq-single",
                description: "What is the time complexity of a binary search on a sorted array of n elements?",
                explanationText: "Binary search repeatedly divides the search interval in half. What is its time complexity?",
                options: ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
                correctAnswer: "O(log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Binary search halves the search space in each iteration. For n elements, it takes log‚ÇÇn steps. Therefore, time complexity is O(log n)."
            },
            {
                questionId: 15,
                title: "Doubling Loop Time Complexity",
                type: "mcq-single",
                description: "What is the time complexity of a loop where the counter doubles each iteration?",
                code: `for i = 1; i <= n; i *= 2:
    print(i)`,
                options: ["O(n)", "O(log n)", "O(n log n)", "O(2‚Åø)"],
                correctAnswer: "O(log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "The loop runs for values: 1, 2, 4, 8, ... until it reaches n. Number of iterations = log‚ÇÇn. Therefore, time complexity is O(log n)."
            },
            {
                questionId: 16,
                title: "Halving Loop Time Complexity",
                type: "mcq-single",
                description: "Analyze the time complexity of nested loops where the outer loop halves and the inner loop runs proportional to the outer counter.",
                code: `for i = n; i > 0; i /= 2:
    for j = 1; j <= i; j++:
        print(i, j)`,
                options: ["O(n)", "O(n log n)", "O(log n)", "O(n¬≤)"],
                correctAnswer: "O(n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Total work = n + n/2 + n/4 + ... ‚âà 2n. This forms a geometric series that sums to O(n)."
            },
            {
                questionId: 17,
                title: "BST Insertion Time Complexity",
                type: "mcq-single",
                description: "What is the time complexity of inserting n elements into a balanced binary search tree?",
                explanationText: "For a balanced BST, each insertion takes O(log n) time. What is the total time for n insertions?",
                options: ["O(n)", "O(log n)", "O(n log n)", "O(n¬≤)"],
                correctAnswer: "O(n log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Each insertion in a balanced BST takes O(log n) time. For n insertions, total time = n √ó O(log n) = O(n log n)."
            },
            {
                questionId: 18,
                title: "Merging Sorted Arrays Time Complexity",
                type: "mcq-single",
                description: "What is the time complexity of merging two sorted arrays of size n and m?",
                explanationText: "The merge operation in Merge Sort compares elements from both arrays. What is its time complexity?",
                options: ["O(1)", "O(n)", "O(n + m)", "O(n log n)"],
                correctAnswer: "O(n + m)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Merging requires comparing elements from both arrays until one is exhausted. In worst case, it requires n + m - 1 comparisons. Therefore, time complexity is O(n + m)."
            },
            {
                questionId: 19,
                title: "Step Loop Time Complexity",
                type: "mcq-single",
                description: "Find the time complexity of nested loops where the inner loop increments by 2.",
                code: `for i = 1; i <= n; i++:
    for j = 1; j <= n; j += 2:
        print(i, j)`,
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(n¬≤/2)"],
                correctAnswer: "O(n¬≤)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Outer loop runs n times. Inner loop runs n/2 times (but constant factors are ignored in Big O). Total iterations = n √ó (n/2) = n¬≤/2 = O(n¬≤)."
            },
            {
                questionId: 20,
                title: "Quick Sort Average Case Complexity",
                type: "mcq-single",
                description: "What is the average-case time complexity of Quick Sort?",
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(log n)"],
                correctAnswer: "O(n log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "On average, Quick Sort chooses good pivots that split the array evenly. The recurrence is T(n) = 2T(n/2) + O(n), which solves to O(n log n)."
            },
            {
                questionId: 21,
                title: "Insertion Sort Shifts Count",
                type: "numeric",
                description: "How many shifts does Insertion Sort make when sorting the array [5, 4, 3, 2, 1] in ascending order?",
                options: [],
                correctAnswer: "10",
                maxScore: 1,
                hasExplanations: true,
                explanation: "For a reverse sorted array of size n, Insertion Sort makes n(n-1)/2 shifts. Here n=5, so 5√ó4/2 = 10 shifts."
            },
            {
                questionId: 22,
                title: "Selection Sort Comparisons for Sorted Array",
                type: "numeric",
                description: "How many element comparisons are made by Selection Sort when sorting the already sorted array [2, 4, 6, 8, 10]?",
                options: [],
                correctAnswer: "10",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Selection Sort always makes n(n-1)/2 comparisons regardless of input order. For n=5, that's 5√ó4/2 = 10 comparisons."
            },
            {
                questionId: 23,
                title: "Merge Sort Merge Operations",
                type: "numeric",
                description: "How many merge operations are performed by Merge Sort on an array of size 8?",
                options: [],
                correctAnswer: "7",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Merge Sort performs exactly n-1 merge operations for an array of size n. For n=8, that's 7 merge operations."
            },
            {
                questionId: 24,
                title: "Quick Sort Worst Case Input",
                type: "mcq-single",
                description: "Which input causes the worst-case behavior in Quick Sort when using the first element as pivot?",
                options: ["Random array", "Already sorted array", "Array with all equal elements", "Alternating high-low values"],
                correctAnswer: "Already sorted array",
                maxScore: 1,
                hasExplanations: true,
                explanation: "When the array is already sorted (ascending or descending) and the first element is chosen as pivot, partitions become extremely unbalanced (1 element vs n-1 elements), leading to O(n¬≤) time."
            },
            {
                questionId: 25,
                title: "Bubble Sort Maximum Passes",
                type: "numeric",
                description: "What is the maximum number of passes Bubble Sort needs to sort an array of 6 elements?",
                options: [],
                correctAnswer: "5",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Bubble Sort requires at most n-1 passes to guarantee sorting an array of size n. For n=6, maximum passes = 5."
            },
            {
                questionId: 26,
                title: "Stable Sorting Algorithms",
                type: "mcq-multiple",
                description: "Which of these sorting algorithms are inherently stable?",
                options: ["Insertion Sort", "Selection Sort", "Merge Sort", "Quick Sort", "Heap Sort"],
                correctAnswer: ["Insertion Sort", "Merge Sort"],
                maxScore: 1,
                hasExplanations: true,
                explanation: "Insertion Sort and Merge Sort preserve the relative order of equal elements. Selection Sort and Quick Sort are generally unstable in their standard implementations. Heap Sort is also unstable."
            },
            {
                questionId: 27,
                title: "Insertion Sort Best Case Complexity",
                type: "mcq-single",
                description: "What is the best-case time complexity of Insertion Sort?",
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(log n)"],
                correctAnswer: "O(n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "When the array is already sorted, Insertion Sort only performs n-1 comparisons and 0 shifts, resulting in O(n) time complexity."
            },
            {
                questionId: 28,
                title: "Heap Sort Build Heap Time",
                type: "mcq-single",
                description: "What is the time complexity to build a max-heap from an unsorted array of n elements?",
                options: ["O(n)", "O(n log n)", "O(log n)", "O(n¬≤)"],
                correctAnswer: "O(n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Building a heap from an unsorted array can be done in linear time O(n) using the bottom-up heapify procedure, not O(n log n) as one might expect."
            },
            {
                questionId: 29,
                title: "Counting Sort Complexity Factors",
                type: "mcq-single",
                description: "Counting Sort's time complexity depends on which factors?",
                options: ["Only number of elements (n)", "Only range of input values (k)", "Both n and k", "Neither n nor k"],
                correctAnswer: "Both n and k",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Counting Sort has time complexity O(n + k), where n is the number of elements and k is the range of input values (max - min + 1)."
            },
            {
                questionId: 30,
                title: "In-Place Sorting Algorithms",
                type: "mcq-multiple",
                description: "Which of these sorting algorithms are in-place (require only O(1) extra space)?",
                options: ["Insertion Sort", "Merge Sort", "Heap Sort", "Quick Sort", "Counting Sort"],
                correctAnswer: ["Insertion Sort", "Heap Sort", "Quick Sort"],
                maxScore: 1,
                hasExplanations: true,
                explanation: "Insertion Sort, Heap Sort, and Quick Sort use only constant extra space. Merge Sort requires O(n) auxiliary space. Counting Sort requires O(k) space where k is the range of values."
            },
            {
                questionId: 31,
                title: "Merge Sort Recurrence Relation",
                type: "mcq-single",
                description: "What is the correct recurrence relation for Merge Sort?",
                options: ["T(n) = T(n-1) + n", "T(n) = 2T(n/2) + n", "T(n) = T(n/2) + log n", "T(n) = 2T(n/2) + log n"],
                correctAnswer: "T(n) = 2T(n/2) + n",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Merge Sort divides the array into two halves (2T(n/2)) and then merges them in O(n) time, giving T(n) = 2T(n/2) + O(n)."
            },
            {
                questionId: 32,
                title: "Selection Sort Minimum Swaps",
                type: "numeric",
                description: "What is the minimum number of swaps Selection Sort performs on any array of 7 elements?",
                options: [],
                correctAnswer: "6",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Selection Sort performs exactly n-1 swaps regardless of input. For n=7, that's always 6 swaps (each iteration swaps the minimum element to its correct position)."
            },
            {
                questionId: 33,
                title: "Quick Sort Partition Result",
                type: "mcq-single",
                description: "After partitioning [6, 2, 9, 1, 5, 8] using Lomuto partition with first element (6) as pivot, what is the array?",
                options: ["[2, 1, 5, 6, 9, 8]", "[1, 2, 5, 6, 9, 8]", "[2, 1, 6, 5, 9, 8]", "[5, 2, 1, 6, 9, 8]"],
                correctAnswer: "[2, 1, 5, 6, 9, 8]",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Lomuto partition moves elements < pivot (6) to the left. Elements 2, 1, 5 are less than 6, so they go before it. Elements 9, 8 are greater, so they go after."
            },
            {
                questionId: 34,
                title: "Radix Sort Time Complexity",
                type: "mcq-single",
                description: "What is the time complexity of Radix Sort for n numbers with d digits each?",
                options: ["O(nd)", "O(d(n + b))", "O(n log d)", "O(n¬≤)"],
                correctAnswer: "O(d(n + b))",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Radix Sort processes each digit using a stable sort (like Counting Sort) which takes O(n + b) time, where b is the base. This is repeated d times, giving O(d(n + b))."
            },
            {
                questionId: 35,
                title: "Optimized Bubble Sort",
                type: "mcq-single",
                description: "What optimization reduces Bubble Sort's best-case time to O(n)?",
                options: ["Using binary search", "Adding a flag to detect no swaps", "Sorting in reverse order", "Using recursion"],
                correctAnswer: "Adding a flag to detect no swaps",
                maxScore: 1,
                hasExplanations: true,
                explanation: "By adding a flag that checks if any swaps occurred in a pass, Bubble Sort can terminate early when the array becomes sorted, achieving O(n) best-case time."
            },
            {
                questionId: 36,
                title: "Shell Sort Gap Sequences",
                type: "mcq-single",
                description: "Which gap sequence for Shell Sort has worst-case O(n¬≤) time complexity?",
                options: ["Shell's original (n/2, n/4, ...)", "Knuth's (3^k-1)/2", "Sedgewick's sequence", "Hibbard's sequence"],
                correctAnswer: "Shell's original (n/2, n/4, ...)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Shell's original sequence (halving each time) has worst-case O(n¬≤) time. More advanced sequences like Knuth's, Sedgewick's, and Hibbard's have better worst-case bounds, typically O(n^(3/2)) or O(n log¬≤ n)."
            },
            {
                questionId: 37,
                title: "Insertion Sort Nearly Sorted",
                type: "numeric",
                description: "How many comparisons does Insertion Sort make on [1, 3, 5, 7, 2, 4, 6] (first 4 elements already sorted)?",
                options: [],
                correctAnswer: "9",
                maxScore: 1,
                hasExplanations: true,
                explanation: "First 4 elements require no comparisons (already in position). Inserting 2: compares with 7,5,3,1 = 4 comparisons. Inserting 4: compares with 7,5,3 = 3 comparisons. Inserting 6: compares with 7,5 = 2 comparisons. Total = 4+3+2 = 9 comparisons."
            },
            {
                questionId: 38,
                title: "Comparison Sort Lower Bound",
                type: "mcq-single",
                description: "What is the lower bound for comparison-based sorting algorithms?",
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(log n)"],
                correctAnswer: "O(n log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Any comparison-based sorting algorithm requires at least Œ©(n log n) comparisons in the worst case to sort n elements, due to the decision tree model having minimum height log(n!) ‚âà n log n."
            },
            {
                questionId: 39,
                title: "Bucket Sort Assumption",
                type: "mcq-single",
                description: "Bucket Sort achieves O(n) average time complexity when:",
                options: ["Elements are integers", "Elements are uniformly distributed", "Array size is small", "Using Insertion Sort within buckets"],
                correctAnswer: "Elements are uniformly distributed",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Bucket Sort assumes input is uniformly distributed over a range, so elements are evenly distributed into buckets. This ensures each bucket has O(1) elements on average, leading to O(n) overall time."
            },
            {
                questionId: 40,
                title: "Quick Sort Tail Recursion Optimization",
                type: "mcq-single",
                description: "What is the main benefit of optimizing tail recursion in Quick Sort?",
                options: ["Reduces comparisons", "Saves stack memory", "Improves pivot selection", "Makes algorithm stable"],
                correctAnswer: "Saves stack memory",
                maxScore: 1,
                hasExplanations: true,
                explanation: "By optimizing tail recursion (recursing on the smaller partition first and using iteration for the larger), Quick Sort's worst-case stack depth reduces from O(n) to O(log n), saving significant memory."
            },
            {
                questionId: 41,
                title: "Timsort Hybrid Composition",
                type: "mcq-single",
                description: "Timsort is a hybrid sorting algorithm combining which two algorithms?",
                options: ["Quick Sort + Insertion Sort", "Merge Sort + Insertion Sort", "Heap Sort + Bubble Sort", "Radix Sort + Counting Sort"],
                correctAnswer: "Merge Sort + Insertion Sort",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Timsort combines Merge Sort with Insertion Sort. It identifies natural runs (already sorted subsequences) using Insertion Sort for small runs, then merges them using a modified Merge Sort."
            },
            {
                questionId: 42,
                title: "Selection Sort Instability Example",
                type: "mcq-multiple",
                description: "Which arrays demonstrate that Selection Sort is unstable? (Assume identical values are distinguishable)",
                options: ["[5, 3, 5, 2]", "[2, 2, 1, 3]", "[4, 1, 4, 2]", "[3, 3, 2, 1]", "[7, 5, 7, 3]"],
                correctAnswer: ["[5, 3, 5, 2]", "[4, 1, 4, 2]", "[7, 5, 7, 3]"],
                maxScore: 1,
                hasExplanations: true,
                explanation: "Selection Sort swaps the minimum element to the front. When there are duplicate values, this swapping can change their original relative order. For example in [5‚ÇÅ, 3, 5‚ÇÇ, 2], after sorting, 5‚ÇÇ may come before 5‚ÇÅ."
            },
            {
                questionId: 43,
                title: "Merge Sort Space Complexity",
                type: "mcq-single",
                description: "What is the space complexity of the standard Merge Sort implementation?",
                options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                correctAnswer: "O(n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Standard Merge Sort requires an auxiliary array of size n to merge subarrays, resulting in O(n) space complexity. There are in-place variants but they are more complex and less efficient."
            },
            {
                questionId: 44,
                title: "Randomized Quick Sort Complexity",
                type: "mcq-single",
                description: "What is the expected time complexity of Randomized Quick Sort?",
                options: ["O(n)", "O(n log n)", "O(n¬≤)", "O(log n)"],
                correctAnswer: "O(n log n)",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Randomized Quick Sort chooses a random pivot, making the worst-case scenario extremely unlikely. The expected time complexity is O(n log n) with high probability."
            },
            {
                questionId: 45,
                title: "Heap Sort Comparison Count",
                type: "numeric",
                description: "What is the maximum number of comparisons required to build a max-heap from 10 elements?",
                options: [],
                correctAnswer: "20",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Building a heap requires at most 2n comparisons in the worst case. For n=10, that's at most 20 comparisons using the heapify procedure."
            },
            {
                questionId: 46,
                title: "Adaptive Sorting Algorithms",
                type: "mcq-multiple",
                description: "Which sorting algorithms are adaptive (perform better on nearly sorted input)?",
                options: ["Insertion Sort", "Selection Sort", "Bubble Sort", "Merge Sort", "Heap Sort"],
                correctAnswer: ["Insertion Sort", "Bubble Sort"],
                maxScore: 1,
                hasExplanations: true,
                explanation: "Insertion Sort and Bubble Sort are adaptive - they take advantage of existing order in the input. Insertion Sort can be O(n) on sorted input, Bubble Sort with optimization can also be O(n). Selection Sort and Heap Sort are not adaptive."
            },
            {
                questionId: 47,
                title: "External Sorting Requirement",
                type: "mcq-single",
                description: "When is external sorting necessary?",
                options: ["For small arrays", "When data fits in RAM", "When data is too large for RAM", "For already sorted data"],
                correctAnswer: "When data is too large for RAM",
                maxScore: 1,
                hasExplanations: true,
                explanation: "External sorting algorithms (like External Merge Sort) are used when the data to be sorted doesn't fit in the computer's main memory and must reside in external storage like disks."
            },
            {
                questionId: 48,
                title: "Three-Way Quick Sort Advantage",
                type: "mcq-single",
                description: "What problem does Three-Way Quick Sort solve efficiently?",
                options: ["Small arrays", "Arrays with many duplicate keys", "Reverse sorted arrays", "Floating point numbers"],
                correctAnswer: "Arrays with many duplicate keys",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Three-Way Quick Sort partitions array into three parts: elements less than pivot, equal to pivot, and greater than pivot. This handles duplicate elements efficiently, preventing O(n¬≤) behavior when many duplicates exist."
            },
            {
                questionId: 49,
                title: "Binary Insertion Sort Benefit",
                type: "mcq-single",
                description: "What does Binary Insertion Sort improve over standard Insertion Sort?",
                options: ["Reduces swaps", "Reduces comparisons", "Reduces memory usage", "Reduces recursion depth"],
                correctAnswer: "Reduces comparisons",
                maxScore: 1,
                hasExplanations: true,
                explanation: "Binary Insertion Sort uses binary search to find the insertion point for each element, reducing comparisons from O(n) to O(log n) per element. However, it still requires O(n) shifts."
            },
            {
                questionId: 50,
                title: "Optimal Sorting Algorithm Selection",
                type: "mcq-single",
                description: "You need to sort 1 million 32-bit integers with limited memory. Which algorithm is most efficient?",
                options: ["Quick Sort", "Merge Sort", "Heap Sort", "Counting Sort"],
                correctAnswer: "Counting Sort",
                maxScore: 1,
                hasExplanations: true,
                explanation: "For 32-bit integers with limited range (0 to 4,294,967,295), Counting Sort gives O(n+k) time complexity. With n=1,000,000 and k=4,294,967,296, the k factor is constant for fixed integer size, making it effectively O(n)."
            }
            
        ];

        let currentQuestionIndex = 0;
        let userAnswers = {};
        let currentUser = {};

        // Initialize Monaco Editor
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            initializeQuiz();
        });

        async function initializeQuiz() {
            console.log('üöÄ Initializing quiz...');
            
            // Initialize with test user first (fallback)
            currentUser = { username: 'TestUser', email: 'test@example.com' };
            userAnswers = {};
            
            // Try to get user session (non-blocking)
            try {
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/session-info', {
                    credentials: 'include',
                    mode: 'cors'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.username && data.email) {
                        currentUser = { username: data.username, email: data.email };
                        console.log('‚úÖ User logged in:', currentUser);
                    }
                }
            } catch (error) {
                console.log('‚ÑπÔ∏è Using test user for demo');
            }
            
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('quizContainer').style.display = 'block';
            
            renderCurrentQuestion();
            updateProgress();
        }

        function renderCurrentQuestion() {
            const question = questions[currentQuestionIndex];
            const container = document.getElementById('questionContainer');
            
            let questionHTML = `
                <div class="question-card">
                    <h4>Question ${currentQuestionIndex + 1}: ${question.title}</h4>
            `;

            // Add description if available
            if (question.description) {
                questionHTML += `<p class="mb-3">${question.description}</p>`;
            }

            // Add explanation text if available
            if (question.explanationText) {
                questionHTML += `<p class="mb-3">${question.explanationText}</p>`;
            }

            // Add code block if available
            if (question.code) {
                questionHTML += `
                    <div class="code-block">
                        <pre>${question.code}</pre>
                    </div>
                `;
            }

            if (question.type === 'mcq-single') {
                questionHTML += `<div class="options-container mt-3">`;
                question.options.forEach((option, index) => {
                    const isSelected = userAnswers[question.questionId] === option;
                    questionHTML += `
                        <label class="option-label ${isSelected ? 'selected' : ''}">
                            <input type="radio" name="q${question.questionId}" value="${option}" 
                                   ${isSelected ? 'checked' : ''} style="display: none;">
                            ${option}
                        </label>
                    `;
                });
                questionHTML += `</div>`;
            } else if (question.type === 'numerical') {
                const currentAnswer = userAnswers[question.questionId] || '';
                questionHTML += `
                    <div class="mt-3">
                        <input type="number" class="numerical-input" 
                               value="${currentAnswer}" 
                               placeholder="Enter your answer"
                               onchange="saveNumericalAnswer(${question.questionId}, this.value)">
                    </div>
                `;
            }

            questionHTML += `</div>`;

            container.innerHTML = questionHTML;

            // Add event listeners for MCQ options
            if (question.type === 'mcq-single') {
                document.querySelectorAll('.option-label').forEach(label => {
                    label.addEventListener('click', function() {
                        document.querySelectorAll('.option-label').forEach(l => l.classList.remove('selected'));
                        this.classList.add('selected');
                        const radio = this.querySelector('input[type="radio"]');
                        radio.checked = true;
                        userAnswers[question.questionId] = radio.value;
                    });
                });
            }
        }

        function saveNumericalAnswer(questionId, value) {
            userAnswers[questionId] = value ? parseInt(value) : '';
        }

        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                renderCurrentQuestion();
                updateProgress();
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderCurrentQuestion();
                updateProgress();
            }
        }

        function updateProgress() {
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
            document.getElementById('prevBtn').disabled = currentQuestionIndex === 0;
            
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.textContent = currentQuestionIndex === questions.length - 1 ? 'Finish ‚Üí' : 'Next ‚Üí';
            
            // Calculate current score
            const currentScore = calculateCurrentScore();
            document.getElementById('scoreText').textContent = `Score: ${currentScore}/${questions.length}`;
        }

        function calculateCurrentScore() {
            let score = 0;
            questions.forEach(question => {
                const userAnswer = userAnswers[question.questionId];
                if (userAnswer !== undefined && userAnswer !== '') {
                    if (userAnswer === question.correctAnswer) {
                        score += question.maxScore;
                    }
                }
            });
            return score;
        }

        async function submitQuiz() {
            const quizData = {
                username: currentUser.username,
                email: currentUser.email,
                topic: "Sorting Algorithms & Time Complexity",
                score: calculateCurrentScore(),
                maxScore: questions.length,
                percentage: Math.round((calculateCurrentScore() / questions.length) * 100),
                timestamp: new Date(),
                questions: questions.map(question => ({
                    questionId: question.questionId,
                    title: question.title,
                    type: question.type,
                    userAnswer: userAnswers[question.questionId] || '',
                    correctAnswer: question.correctAnswer,
                    options: question.options || [],
                    score: (userAnswers[question.questionId] === question.correctAnswer) ? question.maxScore : 0,
                    maxScore: question.maxScore,
                    testResults: [{
                        passed: userAnswers[question.questionId] === question.correctAnswer,
                        expectedAnswer: question.correctAnswer,
                        userAnswer: userAnswers[question.questionId] || ''
                    }],
                    hasExplanations: question.hasExplanations,
                    explanation: question.explanation
                }))
            };

            // Save to backend api/algorithm-submissions
            try {
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/algorithm-submissions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(quizData)
                });

                if (response.ok) {
                    console.log('‚úÖ Quiz results saved successfully');
                } else {
                    console.log('‚ö†Ô∏è Failed to save results, but continuing...');
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Error saving results, but continuing...');
            }

            showResults(quizData);
        }

        function showResults(quizData) {
            document.getElementById('quizContainer').style.display = 'none';
            document.getElementById('resultsContainer').style.display = 'block';
            
            document.getElementById('finalScore').textContent = `${quizData.score}/${quizData.maxScore}`;
            document.getElementById('finalPercentage').textContent = `${quizData.percentage}%`;
            
            const detailedResults = document.getElementById('detailedResults');
            let resultsHTML = `<h4>Detailed Results:</h4>`;
            
            quizData.questions.forEach((question, index) => {
                const isCorrect = question.score > 0;
                resultsHTML += `
                    <div class="question-card ${isCorrect ? 'border-success' : 'border-danger'}">
                        <h6>Q${index + 1}: ${question.title}</h6>
                        <p><strong>Your Answer:</strong> ${question.userAnswer}</p>
                        <p><strong>Correct Answer:</strong> ${question.correctAnswer}</p>
                        <p><strong>Status:</strong> ${isCorrect ? '‚úÖ Correct' : '‚ùå Incorrect'}</p>
                        ${question.hasExplanations ? `
                            <div class="explanation-section">
                                <strong>Explanation:</strong> ${question.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            detailedResults.innerHTML = resultsHTML;
        }

        function restartQuiz() {
            currentQuestionIndex = 0;
            userAnswers = {};
            document.getElementById('resultsContainer').style.display = 'none';
            document.getElementById('quizContainer').style.display = 'block';
            renderCurrentQuestion();
            updateProgress();
        }
    </script>
</body>
</html>
