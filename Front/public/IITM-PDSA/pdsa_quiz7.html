<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Algorithms Programming Quiz</title>
    <!-- Pyodide for Python execution -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <!-- Monaco Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs/loader.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Anti-cheating CSS */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Allow text selection ONLY in code editors */
        .monaco-editor,
        .monaco-editor *,
        .view-lines,
        .view-line {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            -webkit-print-color-adjust: exact;
            pointer-events: auto;
        }
        
        /* Hide scrollbars to prevent inspection */
        ::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }
        
        /* Blur content when window loses focus */
        body.blurred {
            filter: blur(10px);
            pointer-events: none;
        }
        
        /* Warning overlay */
        .warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(220, 53, 69, 0.95);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            font-size: 2rem;
            text-align: center;
            flex-direction: column;
        }
        
        .warning-overlay h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .quiz-container { padding: 30px; }
        .question-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
        }
        .code-editor-container {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin: 20px 0;
            height: 400px;
        }
        .test-cases {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-family: monospace;
        }
        .test-passed {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .test-failed {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .btn:hover { transform: translateY(-2px); }
        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .score-display {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        .results-container { display: none; padding: 30px; }
        .explanation-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(102, 126, 234, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            flex-direction: column;
            color: white;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 1.2rem;
            margin-top: 20px;
        }
        
        /* Security indicator */
        .security-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .security-indicator.warning {
            background: rgba(220, 53, 69, 0.9);
            animation: pulse 1s infinite;
        }
        
        .security-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
        }

        /* Answers Modal */
        .answers-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        .answers-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            width: 800px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }
        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }
    </style>
</head>
<body>
    <!-- Security Indicator -->
    <div id="securityIndicator" class="security-indicator">
        <div class="security-dot"></div>
        <span id="securityText">Monitoring Active</span>
    </div>

    <!-- Warning overlay -->
    <div id="warningOverlay" class="warning-overlay">
        <div>
            <h2>‚ö†Ô∏è SUSPICIOUS ACTIVITY DETECTED</h2>
            <p style="font-size: 1.5rem;">Please return to the quiz window</p>
            <p style="font-size: 1.2rem;">Your activity is being monitored and logged</p>
            <p style="font-size: 1rem; margin-top: 20px;">Attempts logged: <span id="attemptCount">0</span></p>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading Python Environment...</div>
        <small style="margin-top: 10px; opacity: 0.8;">This may take 10-15 seconds</small>
    </div>

    <!-- Answers Modal -->
    <div id="answersModal" class="answers-modal">
        <div class="answers-content">
            <h3>üìù Your Submitted Answers</h3>
            <div id="answersList"></div>
            <div class="text-center mt-4">
                <button class="btn btn-secondary" onclick="closeAnswersModal()">Close</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üî¨ Advanced Algorithms Programming Quiz</h1>
            <p>Implement advanced algorithms including Balanced Search Trees, Scheduling, and Huffman Coding</p>
            <small style="opacity: 0.8;">‚ö†Ô∏è Anti-cheating measures active</small>
        </div>

        <!-- Quiz Container -->
        <div id="quizContainer" class="quiz-container" style="display: none;">
            <div class="progress-container mb-4">
                <div class="d-flex justify-content-between mb-2">
                    <span id="progressText">Question 1 of 10</span>
                    <span id="scoreText">Score: 0/100</span>
                </div>
                <div class="progress">
                    <div class="progress-bar" id="progressFill" style="width: 10%;"></div>
                </div>
            </div>
            
            <div id="questionContainer"></div>
            
            <div class="d-flex justify-content-between mt-4">
                <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()" disabled>‚Üê Previous</button>
                <div>
                    <button class="btn btn-info" onclick="runTests()">üß™ Run Tests</button>
                    <button class="btn" id="nextBtn" onclick="nextQuestion()">Next ‚Üí</button>
                </div>
            </div>
            
            <div class="text-center mt-4">
                <button class="btn btn-success" onclick="submitQuiz()" id="submitBtn">
                    üìä Submit Quiz
                </button>
            </div>
        </div>

        <!-- Results -->
        <div id="resultsContainer" class="results-container">
            <div class="score-display">
                <h2 id="finalScore">0/100</h2>
                <h3 id="finalPercentage">0%</h3>
                <p>Quiz Completed!</p>
            </div>
            <div id="detailedResults"></div>
            <div class="text-center mt-4">
                <button class="btn btn-info me-3" onclick="showMyAnswers()">üìã View My Answers</button>
                <button class="btn" onclick="restartQuiz()">üîÑ Take Quiz Again</button>
            </div>
        </div>
    </div>

    <script>
        // Anti-cheating variables
        let cheatingAttempts = 0;
        let isQuizActive = false;
        let devToolsWarned = false;
        let tabSwitchCount = 0;
        let lastActivityTime = Date.now();
        
        // Global Pyodide instance
        let pyodide = null;
        let pyodideReady = false;

        const questions = [
            {
                id: 1,
                title: "AVL Tree Insertion",
                description: "Implement AVL tree insertion with balancing operations.",
                prompt: `Implement AVL tree insertion with automatic balancing.

REQUIREMENTS:
- Implement Node class with value, left, right, height
- Implement insert(root, key) function
- Implement balance factor calculation and rotations
- Return the root after insertion`,
                starterCode: `class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

def get_height(node):
    if not node:
        return 0
    return node.height

def get_balance(node):
    if not node:
        return 0
    return get_height(node.left) - get_height(node.right)

def left_rotate(z):
    y = z.right
    T2 = y.left
    
    y.left = z
    z.right = T2
    
    z.height = 1 + max(get_height(z.left), get_height(z.right))
    y.height = 1 + max(get_height(y.left), get_height(y.right))
    
    return y

def right_rotate(z):
    y = z.left
    T3 = y.right
    
    y.right = z
    z.left = T3
    
    z.height = 1 + max(get_height(z.left), get_height(z.right))
    y.height = 1 + max(get_height(y.left), get_height(y.right))
    
    return y

def insert(root, key):
    if not root:
        return Node(key)
    
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    
    root.height = 1 + max(get_height(root.left), get_height(root.right))
    
    balance = get_balance(root)
    
    # Left Left Case
    if balance > 1 and key < root.left.key:
        return right_rotate(root)
    
    # Right Right Case
    if balance < -1 and key > root.right.key:
        return left_rotate(root)
    
    # Left Right Case
    if balance > 1 and key > root.left.key:
        root.left = left_rotate(root.left)
        return right_rotate(root)
    
    # Right Left Case
    if balance < -1 and key < root.right.key:
        root.right = right_rotate(root.right)
        return left_rotate(root)
    
    return root

# Test your implementation
root = None
for key in [10, 20, 30, 40, 50, 25]:
    root = insert(root, key)`,
                testCases: [
                    { 
                        input: [[10, 20, 30]], 
                        expected: { 
                            "root_key": 20, 
                            "left_key": 10, 
                            "right_key": 30
                        } 
                    }
                ],
                functionName: 'insert',
                points: 10
            },
            {
                id: 2,
                title: "FCFS Scheduling",
                description: "Implement First-Come-First-Served CPU scheduling algorithm.",
                prompt: `Implement FCFS scheduling algorithm.

REQUIREMENTS:
- Input: List of processes with arrival_time and burst_time
- Output: Dictionary with completion_time, turnaround_time, waiting_time
- Calculate average waiting time and turnaround time`,
                starterCode: `def fcfs_scheduling(processes):
    """
    processes: list of tuples (process_id, arrival_time, burst_time)
    returns: dictionary with process metrics
    """
    n = len(processes)
    completion_time = [0] * n
    turnaround_time = [0] * n
    waiting_time = [0] * n
    
    # Sort by arrival time
    processes.sort(key=lambda x: x[1])
    
    completion_time[0] = processes[0][1] + processes[0][2]
    turnaround_time[0] = completion_time[0] - processes[0][1]
    waiting_time[0] = turnaround_time[0] - processes[0][2]
    
    for i in range(1, n):
        completion_time[i] = max(completion_time[i-1], processes[i][1]) + processes[i][2]
        turnaround_time[i] = completion_time[i] - processes[i][1]
        waiting_time[i] = turnaround_time[i] - processes[i][2]
    
    avg_waiting = sum(waiting_time) / n
    avg_turnaround = sum(turnaround_time) / n
    
    return {
        "completion_times": completion_time,
        "turnaround_times": turnaround_time,
        "waiting_times": waiting_time,
        "avg_waiting": round(avg_waiting, 2),
        "avg_turnaround": round(avg_turnaround, 2)
    }

# Test your function
processes = [(1, 0, 10), (2, 1, 5), (3, 2, 8)]
print(fcfs_scheduling(processes))`,
                testCases: [
                    { 
                        input: [[[1, 0, 10], [2, 1, 5], [3, 2, 8]]], 
                        expected: { 
                            "avg_waiting": 6.33,
                            "avg_turnaround": 13.33
                        } 
                    }
                ],
                functionName: 'fcfs_scheduling',
                points: 10
            },
            {
                id: 3,
                title: "SJF Scheduling",
                description: "Implement Shortest Job First (Non-preemptive) scheduling.",
                prompt: `Implement SJF non-preemptive scheduling algorithm.

REQUIREMENTS:
- Input: List of processes with arrival_time and burst_time
- Output: Dictionary with completion_time, turnaround_time, waiting_time
- Always select the process with shortest burst time`,
                starterCode: `def sjf_scheduling(processes):
    """
    processes: list of tuples (process_id, arrival_time, burst_time)
    returns: dictionary with process metrics
    """
    n = len(processes)
    completion_time = [0] * n
    turnaround_time = [0] * n
    waiting_time = [0] * n
    remaining = [p[2] for p in processes]
    completed = 0
    current_time = 0
    
    while completed != n:
        # Find processes that have arrived and not completed
        available = []
        for i in range(n):
            if processes[i][1] <= current_time and remaining[i] > 0:
                available.append((i, processes[i][2]))
        
        if not available:
            current_time += 1
            continue
        
        # Select process with shortest burst time
        available.sort(key=lambda x: x[1])
        idx = available[0][0]
        
        # Execute the process
        current_time += processes[idx][2]
        completion_time[idx] = current_time
        turnaround_time[idx] = completion_time[idx] - processes[idx][1]
        waiting_time[idx] = turnaround_time[idx] - processes[idx][2]
        remaining[idx] = 0
        completed += 1
    
    avg_waiting = sum(waiting_time) / n
    avg_turnaround = sum(turnaround_time) / n
    
    return {
        "completion_times": completion_time,
        "turnaround_times": turnaround_time,
        "waiting_times": waiting_time,
        "avg_waiting": round(avg_waiting, 2),
        "avg_turnaround": round(avg_turnaround, 2)
    }

# Test your function
processes = [(1, 0, 6), (2, 2, 8), (3, 3, 7), (4, 5, 3)]
print(sjf_scheduling(processes))`,
                testCases: [
                    { 
                        input: [[[1, 0, 6], [2, 2, 8], [3, 3, 7], [4, 5, 3]]], 
                        expected: { 
                            "avg_waiting": 7.0,
                            "avg_turnaround": 13.0
                        } 
                    }
                ],
                functionName: 'sjf_scheduling',
                points: 10
            },
            {
                id: 4,
                title: "Round Robin Scheduling",
                description: "Implement Round Robin CPU scheduling algorithm.",
                prompt: `Implement Round Robin scheduling with time quantum.

REQUIREMENTS:
- Input: List of processes and time quantum
- Output: Dictionary with completion_time, turnaround_time, waiting_time
- Handle processes in circular fashion`,
                starterCode: `def round_robin(processes, time_quantum):
    """
    processes: list of tuples (process_id, arrival_time, burst_time)
    time_quantum: integer time slice
    returns: dictionary with process metrics
    """
    n = len(processes)
    remaining = [p[2] for p in processes]
    completion_time = [0] * n
    turnaround_time = [0] * n
    waiting_time = [0] * n
    current_time = 0
    
    queue = []
    completed = 0
    idx = 0
    
    while completed < n:
        # Add processes that have arrived
        for i in range(n):
            if processes[i][1] <= current_time and remaining[i] > 0 and i not in queue:
                queue.append(i)
        
        if not queue:
            current_time += 1
            continue
        
        idx = queue.pop(0)
        
        if remaining[idx] <= time_quantum:
            current_time += remaining[idx]
            completion_time[idx] = current_time
            turnaround_time[idx] = completion_time[idx] - processes[idx][1]
            waiting_time[idx] = turnaround_time[idx] - processes[idx][2]
            remaining[idx] = 0
            completed += 1
        else:
            current_time += time_quantum
            remaining[idx] -= time_quantum
            # Add back to queue if not finished
            queue.append(idx)
    
    avg_waiting = sum(waiting_time) / n
    avg_turnaround = sum(turnaround_time) / n
    
    return {
        "completion_times": completion_time,
        "turnaround_times": turnaround_time,
        "waiting_times": waiting_time,
        "avg_waiting": round(avg_waiting, 2),
        "avg_turnaround": round(avg_turnaround, 2)
    }

# Test your function
processes = [(1, 0, 10), (2, 1, 5), (3, 2, 8)]
print(round_robin(processes, 2))`,
                testCases: [
                    { 
                        input: [[[1, 0, 10], [2, 1, 5], [3, 2, 8]], 2], 
                        expected: { 
                            "avg_waiting": 11.33,
                            "avg_turnaround": 18.33
                        } 
                    }
                ],
                functionName: 'round_robin',
                points: 10
            },
            {
                id: 5,
                title: "Priority Scheduling",
                description: "Implement Priority-based CPU scheduling (Non-preemptive).",
                prompt: `Implement Priority scheduling algorithm.

REQUIREMENTS:
- Input: List of processes with priority (lower number = higher priority)
- Output: Dictionary with completion_time, turnaround_time, waiting_time
- Sort processes by priority`,
                starterCode: `def priority_scheduling(processes):
    """
    processes: list of tuples (process_id, arrival_time, burst_time, priority)
    returns: dictionary with process metrics
    """
    n = len(processes)
    completion_time = [0] * n
    turnaround_time = [0] * n
    waiting_time = [0] * n
    
    # Sort by arrival time first, then by priority
    sorted_processes = sorted(processes, key=lambda x: (x[1], x[3]))
    
    current_time = 0
    for i in range(n):
        if current_time < sorted_processes[i][1]:
            current_time = sorted_processes[i][1]
        
        completion_time[i] = current_time + sorted_processes[i][2]
        turnaround_time[i] = completion_time[i] - sorted_processes[i][1]
        waiting_time[i] = turnaround_time[i] - sorted_processes[i][2]
        current_time = completion_time[i]
    
    avg_waiting = sum(waiting_time) / n
    avg_turnaround = sum(turnaround_time) / n
    
    return {
        "completion_times": completion_time,
        "turnaround_times": turnaround_time,
        "waiting_times": waiting_time,
        "avg_waiting": round(avg_waiting, 2),
        "avg_turnaround": round(avg_turnaround, 2)
    }

# Test your function
processes = [(1, 0, 10, 3), (2, 0, 5, 1), (3, 0, 8, 2)]
print(priority_scheduling(processes))`,
                testCases: [
                    { 
                        input: [[[1, 0, 10, 3], [2, 0, 5, 1], [3, 0, 8, 2]]], 
                        expected: { 
                            "avg_waiting": 6.67,
                            "avg_turnaround": 13.67
                        } 
                    }
                ],
                functionName: 'priority_scheduling',
                points: 10
            },
            {
                id: 6,
                title: "Huffman Coding - Tree Building",
                description: "Build Huffman coding tree from character frequencies.",
                prompt: `Implement Huffman tree building from character frequencies.

REQUIREMENTS:
- Input: Dictionary of characters and their frequencies
- Output: Huffman tree root node
- Use min-heap to build the tree
- Return the root of Huffman tree`,
                starterCode: `import heapq

class HuffmanNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
    
    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(freq_dict):
    """
    freq_dict: dictionary with characters as keys and frequencies as values
    returns: root node of Huffman tree
    """
    heap = []
    for char, freq in freq_dict.items():
        heapq.heappush(heap, HuffmanNode(char, freq))
    
    while len(heap) > 1:
        node1 = heapq.heappop(heap)
        node2 = heapq.heappop(heap)
        
        merged = HuffmanNode(None, node1.freq + node2.freq)
        merged.left = node1
        merged.right = node2
        
        heapq.heappush(heap, merged)
    
    return heap[0] if heap else None

# Test your function
freq = {'a': 5, 'b': 9, 'c': 12, 'd': 13, 'e': 16, 'f': 45}
root = build_huffman_tree(freq)
print(f"Root frequency: {root.freq if root else 'None'}")`,
                testCases: [
                    { 
                        input: [{'a': 5, 'b': 9, 'c': 12, 'd': 13}], 
                        expected: { 
                            "root_freq": 39
                        } 
                    }
                ],
                functionName: 'build_huffman_tree',
                points: 10
            },
            {
                id: 7,
                title: "Huffman Coding - Code Generation",
                description: "Generate Huffman codes from Huffman tree.",
                prompt: `Generate Huffman codes by traversing the Huffman tree.

REQUIREMENTS:
- Input: Root of Huffman tree
- Output: Dictionary with characters as keys and their Huffman codes as values
- Traverse the tree to assign 0 for left and 1 for right`,
                starterCode: `def generate_huffman_codes(root):
    """
    root: root node of Huffman tree
    returns: dictionary with characters and their Huffman codes
    """
    def build_codes(node, current_code, codes):
        if node is None:
            return
        
        if node.char is not None:
            codes[node.char] = current_code
            return
        
        build_codes(node.left, current_code + "0", codes)
        build_codes(node.right, current_code + "1", codes)
    
    codes = {}
    if root:
        build_codes(root, "", codes)
    return codes

# Test your function
freq = {'a': 5, 'b': 9, 'c': 12, 'd': 13}
tree = build_huffman_tree(freq)
codes = generate_huffman_codes(tree)
print(codes)`,
                testCases: [
                    { 
                        input: [{'a': 40, 'b': 30, 'c': 20, 'd': 10}], 
                        expected: { 
                            "codes_count": 4
                        } 
                    }
                ],
                functionName: 'generate_huffman_codes',
                points: 10
            },
            {
                id: 8,
                title: "Huffman Encoding",
                description: "Encode a string using Huffman coding.",
                prompt: `Encode a string using generated Huffman codes.

REQUIREMENTS:
- Input: String to encode and Huffman codes dictionary
- Output: Encoded binary string
- Replace each character with its Huffman code`,
                starterCode: `def huffman_encode(text, huffman_codes):
    """
    text: string to encode
    huffman_codes: dictionary from generate_huffman_codes
    returns: encoded binary string
    """
    encoded = ""
    for char in text:
        if char in huffman_codes:
            encoded += huffman_codes[char]
        else:
            raise ValueError(f"Character '{char}' not in Huffman codes")
    return encoded

# Test your function
freq = {'a': 5, 'b': 9, 'c': 12, 'd': 13}
tree = build_huffman_tree(freq)
codes = generate_huffman_codes(tree)
encoded = huffman_encode("aabbccdd", codes)
print(encoded)`,
                testCases: [
                    { 
                        input: ["abc", {'a': '0', 'b': '10', 'c': '11'}], 
                        expected: "01011" 
                    }
                ],
                functionName: 'huffman_encode',
                points: 10
            },
            {
                id: 9,
                title: "Huffman Decoding",
                description: "Decode a binary string using Huffman tree.",
                prompt: `Decode a binary string using Huffman tree.

REQUIREMENTS:
- Input: Encoded binary string and Huffman tree root
- Output: Decoded original string
- Traverse the tree based on binary bits (0=left, 1=right)`,
                starterCode: `def huffman_decode(encoded_text, root):
    """
    encoded_text: binary string to decode
    root: root of Huffman tree
    returns: decoded string
    """
    decoded = ""
    current = root
    for bit in encoded_text:
        if bit == '0':
            current = current.left
        else:
            current = current.right
        
        if current.char is not None:
            decoded += current.char
            current = root
    
    return decoded

# Test your function
freq = {'a': 5, 'b': 9, 'c': 12, 'd': 13}
tree = build_huffman_tree(freq)
encoded = "01011"  # Example encoded string
decoded = huffman_decode(encoded, tree)
print(decoded)`,
                testCases: [
                    { 
                        input: ["01011", {'a': '0', 'b': '10', 'c': '11'}], 
                        expected: "abc" 
                    }
                ],
                functionName: 'huffman_decode',
                points: 10
            },
            {
                id: 10,
                title: "Binary Search Tree Operations",
                description: "Implement basic BST operations: insert, search, and inorder traversal.",
                prompt: `Implement Binary Search Tree operations.

REQUIREMENTS:
- Implement BST insert, search, and inorder traversal
- Return appropriate values for each operation
- Handle edge cases like empty tree`,
                starterCode: `class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def bst_insert(root, key):
    if root is None:
        return BSTNode(key)
    
    if key < root.key:
        root.left = bst_insert(root.left, key)
    else:
        root.right = bst_insert(root.right, key)
    
    return root

def bst_search(root, key):
    if root is None or root.key == key:
        return root is not None
    
    if key < root.key:
        return bst_search(root.left, key)
    return bst_search(root.right, key)

def bst_inorder(root):
    result = []
    def inorder_traversal(node):
        if node:
            inorder_traversal(node.left)
            result.append(node.key)
            inorder_traversal(node.right)
    inorder_traversal(root)
    return result

# Test your implementation
root = None
keys = [50, 30, 70, 20, 40, 60, 80]
for key in keys:
    root = bst_insert(root, key)

print("Inorder:", bst_inorder(root))
print("Search 40:", bst_search(root, 40))
print("Search 90:", bst_search(root, 90))`,
                testCases: [
                    { 
                        input: [[50, 30, 70, 20, 40, 60, 80]], 
                        expected: { 
                            "inorder": [20, 30, 40, 50, 60, 70, 80],
                            "search_40": true,
                            "search_90": false
                        } 
                    }
                ],
                functionName: 'bst_inorder',
                points: 10
            }
        ];

        let currentQuestionIndex = 0;
        let userAnswers = {};
        let currentUser = {};
        let editors = {};
        let submittedQuizData = null;

        // ===== ANTI-CHEATING SYSTEM =====
        
        function initializeAntiCheating() {
            // Disable right-click everywhere except code editor
            document.addEventListener('contextmenu', function(e) {
                if (!e.target.closest('.monaco-editor')) {
                    e.preventDefault();
                    recordCheatingAttempt('right_click');
                    return false;
                }
            });
            
            // Disable keyboard shortcuts (except in editor)
            document.addEventListener('keydown', function(e) {
                // Allow all keys in Monaco editor
                if (e.target.closest('.monaco-editor') || e.target.classList.contains('monaco-editor')) {
                    return true;
                }
                
                // Disable F12, Ctrl+Shift+I, Ctrl+U, Ctrl+S, Print Screen
                if (e.keyCode === 123 || // F12
                    (e.ctrlKey && e.shiftKey && e.keyCode === 73) || // Ctrl+Shift+I
                    (e.ctrlKey && e.keyCode === 85) || // Ctrl+U
                    (e.ctrlKey && e.keyCode === 83) || // Ctrl+S
                    e.keyCode === 44) { // Print Screen
                    e.preventDefault();
                    recordCheatingAttempt('keyboard_shortcut');
                    return false;
                }
                
                // Disable Ctrl+A, Ctrl+C, Ctrl+V outside editor
                if (e.ctrlKey && (e.keyCode === 65 || e.keyCode === 67 || e.keyCode === 86)) {
                    e.preventDefault();
                    recordCheatingAttempt('copy_attempt');
                    return false;
                }
            });
            
            // Detect developer tools
            let devtools = {open: false, orientation: null};
            const threshold = 160;
            
            setInterval(function() {
                if (window.outerHeight - window.innerHeight > threshold || 
                    window.outerWidth - window.innerWidth > threshold) {
                    if (!devtools.open && isQuizActive) {
                        devtools.open = true;
                        recordCheatingAttempt('developer_tools');
                        if (!devToolsWarned) {
                            alert('‚ö†Ô∏è Developer tools detected! This attempt has been logged.\n\nContinued violations may result in quiz auto-submission.');
                            devToolsWarned = true;
                        }
                    }
                } else {
                    devtools.open = false;
                }
            }, 500);
            
            // Detect window focus changes (tab switching)
            window.addEventListener('blur', function() {
                if (isQuizActive) {
                    tabSwitchCount++;
                    document.body.classList.add('blurred');
                    document.getElementById('warningOverlay').style.display = 'flex';
                    document.getElementById('attemptCount').textContent = cheatingAttempts;
                    recordCheatingAttempt('window_blur_tab_switch');
                }
            });
            
            window.addEventListener('focus', function() {
                document.body.classList.remove('blurred');
                document.getElementById('warningOverlay').style.display = 'none';
                updateSecurityIndicator();
            });
            
            // Monitor for screenshot attempts
            document.addEventListener('keyup', function(e) {
                if (e.keyCode === 44 && isQuizActive) { // Print Screen released
                    recordCheatingAttempt('screenshot_attempt');
                    alert('‚ö†Ô∏è Screenshot attempt detected and logged!');
                }
            });
            
            // Disable printing
            window.addEventListener('beforeprint', function(e) {
                if (isQuizActive) {
                    recordCheatingAttempt('print_attempt');
                    e.preventDefault();
                    alert('‚ö†Ô∏è Printing is disabled during the quiz.');
                    return false;
                }
            });
            
            // Monitor visibility changes
            document.addEventListener('visibilitychange', function() {
                if (document.hidden && isQuizActive) {
                    recordCheatingAttempt('visibility_change');
                }
            });
            
            // Prevent text selection outside editor
            document.addEventListener('selectstart', function(e) {
                if (!e.target.closest('.monaco-editor') && isQuizActive) {
                    recordCheatingAttempt('text_selection');
                    return false;
                }
            });
        }
        
        // Record cheating attempts
        function recordCheatingAttempt(type) {
            cheatingAttempts++;
            console.warn(`Cheating attempt #${cheatingAttempts}: ${type}`);
            
            // Update UI
            document.getElementById('attemptCount').textContent = cheatingAttempts;
            updateSecurityIndicator(true);
            
            // Log to server
            if (currentUser.username && currentUser.email) {
                fetch('https://sanghamitra-learnworld.vercel.app/api/log-cheating', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: currentUser.username,
                        email: currentUser.email,
                        cheatingType: type,
                        timestamp: new Date(),
                        currentQuestion: currentQuestionIndex + 1,
                        totalAttempts: cheatingAttempts
                    })
                }).catch(err => console.error('Failed to log cheating attempt:', err));
            }
            
            // Auto-submit after too many attempts
            if (cheatingAttempts >= 10) {
                alert('‚ö†Ô∏è Too many suspicious activities detected!\n\nYour quiz will be auto-submitted now.');
                submitQuiz();
            } else if (cheatingAttempts >= 5) {
                alert(`‚ö†Ô∏è Warning: ${cheatingAttempts} suspicious activities detected!\n\nQuiz will auto-submit at 10 attempts.`);
            }
        }
        
        // Update security indicator
        function updateSecurityIndicator(warning = false) {
            const indicator = document.getElementById('securityIndicator');
            const text = document.getElementById('securityText');
            
            if (warning) {
                indicator.classList.add('warning');
                text.textContent = `${cheatingAttempts} Violations Detected`;
                setTimeout(() => {
                    indicator.classList.remove('warning');
                    text.textContent = 'Monitoring Active';
                }, 3000);
            }
        }

        // ===== QUIZ INITIALIZATION =====

        async function initPyodide() {
            const loadingText = document.querySelector('.loading-text');
            
            try {
                loadingText.textContent = 'Loading Python interpreter...';
                
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                
                loadingText.textContent = 'Python ready! Initializing quiz...';
                pyodideReady = true;
                
                require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs' }});
                require(['vs/editor/editor.main'], function() {
                    setTimeout(() => initializeQuiz(), 500);
                });
                
            } catch (error) {
                console.error('Failed to load Pyodide:', error);
                loadingText.textContent = 'Error loading Python. Please refresh.';
                alert('Failed to load Python environment. Please refresh the page.');
            }
        }

        async function initializeQuiz() {
            console.log('üöÄ Initializing quiz...');
            
            // Initialize anti-cheating FIRST
            initializeAntiCheating();
            
            currentUser = { username: 'TestUser', email: 'test@example.com' };
            userAnswers = {};
            
            try {
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/session-info', {
                    credentials: 'include',
                    mode: 'cors'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.username && data.email) {
                        currentUser = { username: data.username, email: data.email };
                        console.log('‚úÖ User logged in:', currentUser);
                    }
                }
            } catch (error) {
                console.log('‚ÑπÔ∏è Using test user for demo');
            }
            
            // Enable quiz monitoring
            isQuizActive = true;
            
            document.getElementById('loadingOverlay').style.display = 'none';
            document.getElementById('quizContainer').style.display = 'block';
            
            // Request fullscreen (optional, user can decline)
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen request declined:', err);
                });
            }
            
            renderCurrentQuestion();
            updateProgress();
        }

        function renderCurrentQuestion() {
            const container = document.getElementById('questionContainer');
            const question = questions[currentQuestionIndex];
            
            container.innerHTML = `
                <div class="question-card">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h3>${question.title}</h3>
                        <span class="badge bg-primary">${question.points} points</span>
                    </div>
                    <p class="mb-3">${question.description}</p>
                    <div class="alert alert-info">
                        <h6>Problem:</h6>
                        <pre style="white-space: pre-wrap;">${question.prompt}</pre>
                    </div>
                    <div class="explanation-section">
                        <h6>üìù Important:</h6>
                        <p>Include explanations as comments for full credit.</p>
                    </div>
                    <div id="editor-${question.id}" class="code-editor-container"></div>
                    <div class="test-cases">
                        <h6>Test Cases:</h6>
                        ${question.testCases.map((test, i) => `
                            <div><strong>Test ${i+1}:</strong> ${formatTestCase(test)}</div>
                        `).join('')}
                    </div>
                    <div id="testResults-${question.id}"></div>
                </div>
            `;
            
            const editor = monaco.editor.create(document.getElementById(`editor-${question.id}`), {
                value: userAnswers[question.id] || question.starterCode,
                language: 'python',
                theme: 'vs-light',
                fontSize: 14,
                automaticLayout: true,
                minimap: { enabled: false },
                scrollBeyondLastLine: false
            });
            
            editors[question.id] = editor;
            editor.onDidChangeModelContent(() => {
                userAnswers[question.id] = editor.getValue();
            });
        }

        function formatTestCase(test) {
            const input = Array.isArray(test.input) ? JSON.stringify(test.input) : test.input;
            const expected = JSON.stringify(test.expected);
            return `Input: ${input} ‚Üí Expected: ${expected}`;
        }

        async function executePythonTests(code, question) {
            if (!pyodideReady) {
                throw new Error('Python environment not ready');
            }

            const results = [];
            
            for (let i = 0; i < question.testCases.length; i++) {
                const testCase = question.testCases[i];
                
                try {
                    await pyodide.runPythonAsync(`
import sys
for name in list(globals().keys()):
    if not name.startswith('__') and name not in ['sys']:
        try:
            del globals()[name]
        except:
            pass
                    `);
                    
                    await pyodide.runPythonAsync(code);
                    
                    let functionCall;
                    if (Array.isArray(testCase.input)) {
                        functionCall = `${question.functionName}(${testCase.input.map(v => 
                            typeof v === 'object' ? JSON.stringify(v).replace(/"/g, "'") : v
                        ).join(', ')})`;
                    } else {
                        functionCall = `${question.functionName}(${testCase.input})`;
                    }
                    
                    const result = await pyodide.runPythonAsync(functionCall);
                    
                    let output;
                    if (result && typeof result === 'object' && result.toJs) {
                        output = result.toJs({ dict_converter: Object.fromEntries });
                    } else {
                        output = result;
                    }
                    
                    // Convert Python True/False to JavaScript true/false
                    if (typeof output === 'boolean') {
                        output = output;
                    }
                    
                    const passed = deepEqual(output, testCase.expected);
                    
                    results.push({
                        passed,
                        output,
                        expected: testCase.expected,
                        error: null
                    });
                    
                } catch (error) {
                    results.push({
                        passed: false,
                        output: null,
                        expected: testCase.expected,
                        error: error.message
                    });
                }
            }
            
            return results;
        }

        function deepEqual(a, b) {
            if (a === b) return true;
            if (a == null || b == null) return false;
            if (typeof a !== typeof b) return false;
            
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) return false;
                for (let i = 0; i < a.length; i++) {
                    if (!deepEqual(a[i], b[i])) return false;
                }
                return true;
            }
            
            if (typeof a === 'object' && typeof b === 'object') {
                const keysA = Object.keys(a).sort();
                const keysB = Object.keys(b).sort();
                if (keysA.length !== keysB.length) return false;
                for (let key of keysA) {
                    if (!deepEqual(a[key], b[key])) return false;
                }
                return true;
            }
            
            return false;
        }

        async function runTests() {
            if (!pyodideReady) {
                alert('Python environment is still loading. Please wait...');
                return;
            }

            const question = questions[currentQuestionIndex];
            const code = editors[question.id].getValue();
            const resultsDiv = document.getElementById(`testResults-${question.id}`);
            
            resultsDiv.innerHTML = '<h6>üîß Running tests...</h6>';
            
            try {
                const testResults = await executePythonTests(code, question);
                
                let testHtml = '<h6>Test Results:</h6>';
                let passedCount = 0;
                
                testResults.forEach((result, i) => {
                    if (result.passed) passedCount++;
                    
                    testHtml += `
                        <div class="test-result ${result.passed ? 'test-passed' : 'test-failed'}">
                            Test ${i+1}: ${result.passed ? '‚úì PASSED' : '‚úó FAILED'}
                            ${result.error ? `<br>Error: ${result.error}` : ''}
                            ${!result.passed && !result.error ? `<br>Expected: ${JSON.stringify(result.expected)}<br>Got: ${JSON.stringify(result.output)}` : ''}
                        </div>
                    `;
                });
                
                testHtml += `
                    <div class="mt-3">
                        <strong>Summary:</strong> ${passedCount}/${testResults.length} tests passed
                    </div>
                    <div class="mt-2">
                        <strong>Explanation Check:</strong>
                        ${checkExplanations(code) ? '‚úì Explanations found' : '‚ö† Add comments'}
                    </div>
                `;
                
                resultsDiv.innerHTML = testHtml;
                
            } catch (error) {
                console.error('Test execution error:', error);
                resultsDiv.innerHTML = `
                    <div class="test-result test-failed">
                        ‚ùå Error: ${error.message}
                    </div>
                `;
            }
        }

        function checkExplanations(code) {
            const comments = code.match(/#.+/g) || [];
            return comments.some(c => c.length > 20) && comments.length >= 2;
        }

        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                renderCurrentQuestion();
                updateProgress();
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderCurrentQuestion();
                updateProgress();
            }
        }

        function updateProgress() {
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
            document.getElementById('prevBtn').disabled = currentQuestionIndex === 0;
            
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.textContent = currentQuestionIndex === questions.length - 1 ? 'Finish ‚Üí' : 'Next ‚Üí';
        }

        async function submitQuiz() {
            if (!confirm('Submit your quiz? Make sure you\'ve tested all answers.')) return;

            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.textContent = '‚è≥ Submitting...';
            
            // Disable monitoring
            isQuizActive = false;

            let totalScore = 0;
            const results = [];
            
            for (const question of questions) {
                const code = userAnswers[question.id] || '';
                
                try {
                    const testResults = await executePythonTests(code, question);
                    const passedTests = testResults.filter(r => r.passed).length;
                    const hasExplanations = checkExplanations(code);
                    const bonus = hasExplanations ? question.points * 0.2 : 0;
                    const score = Math.min(
                        Math.round((passedTests / testResults.length) * question.points) + bonus,
                        question.points
                    );
                    
                    totalScore += score;
                    results.push({
                        questionId: question.id,
                        title: question.title,
                        code,
                        score,
                        maxScore: question.points,
                        passedTests,
                        totalTests: testResults.length,
                        hasExplanations
                    });
                } catch (error) {
                    results.push({
                        questionId: question.id,
                        title: question.title,
                        code,
                        score: 0,
                        maxScore: question.points,
                        passedTests: 0,
                        totalTests: question.testCases.length,
                        hasExplanations: checkExplanations(code),
                        error: error.message
                    });
                }
            }
            
            const maxScore = questions.reduce((sum, q) => sum + q.points, 0);
            const percentage = Math.round((totalScore / maxScore) * 100);
            
            submittedQuizData = {
                username: currentUser.username,
                email: currentUser.email,
                topic: 'Advanced Algorithms',
                score: totalScore,
                maxScore,
                percentage,
                questions: results,
                timestamp: new Date().toISOString(),
                cheatingAttempts: cheatingAttempts,
                tabSwitches: tabSwitchCount
            };
            
            try {
                const response = await fetch('https://sanghamitra-learnworld.vercel.app/api/algorithm-submissions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(submittedQuizData)
                });
                
                if (response.ok) {
                    alert('‚úÖ Quiz submitted successfully!');
                } else {
                    throw new Error(`Server error: ${response.status}`);
                }
            } catch (error) {
                console.error('Submission error:', error);
                alert('‚ö†Ô∏è Could not submit to server, but showing results.');
            }
            
            showResults(submittedQuizData);
        }

        function showResults(quizData) {
            document.getElementById('quizContainer').style.display = 'none';
            document.getElementById('resultsContainer').style.display = 'block';
            document.getElementById('finalScore').textContent = `${quizData.score}/${quizData.maxScore}`;
            document.getElementById('finalPercentage').textContent = `${quizData.percentage}%`;
            
            const detailedResults = document.getElementById('detailedResults');
            detailedResults.innerHTML = `
                <h4>Detailed Results</h4>
                ${quizData.cheatingAttempts > 0 ? `
                    <div class="alert alert-warning">
                        ‚ö†Ô∏è Security Note: ${quizData.cheatingAttempts} suspicious activities were detected during this quiz.
                    </div>
                ` : ''}
                ${quizData.questions.map(q => `
                    <div class="card mb-3">
                        <div class="card-body">
                            <h6>${q.title}: ${q.score}/${q.maxScore} points</h6>
                            <div class="progress mb-2">
                                <div class="progress-bar" style="width: ${(q.score/q.maxScore)*100}%"></div>
                            </div>
                            <small>Tests: ${q.passedTests}/${q.totalTests} | ${q.hasExplanations ? '‚úì Explained' : '‚ö† No explanation'}</small>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function showMyAnswers() {
            if (!submittedQuizData) {
                alert('No quiz data found. Please submit the quiz first.');
                return;
            }

            const answersList = document.getElementById('answersList');
            answersList.innerHTML = submittedQuizData.questions.map(q => `
                <div class="mb-4">
                    <h5>${q.title} (Score: ${q.score}/${q.maxScore})</h5>
                    <div class="code-block">${escapeHtml(q.code)}</div>
                </div>
            `).join('');

            document.getElementById('answersModal').style.display = 'flex';
        }

        function closeAnswersModal() {
            document.getElementById('answersModal').style.display = 'none';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function restartQuiz() {
            currentQuestionIndex = 0;
            userAnswers = {};
            editors = {};
            cheatingAttempts = 0;
            tabSwitchCount = 0;
            submittedQuizData = null;
            isQuizActive = true;
            document.getElementById('resultsContainer').style.display = 'none';
            document.getElementById('quizContainer').style.display = 'block';
            renderCurrentQuestion();
            updateProgress();
        }

        // Start loading Pyodide immediately
        window.addEventListener('DOMContentLoaded', initPyodide);
    </script>
</body>
</html>
